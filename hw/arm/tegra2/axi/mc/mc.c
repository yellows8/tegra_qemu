/*
 * ARM NVIDIA Tegra2 emulation.
 *
 * Copyright (c) 2014-2015 Dmitry Osipenko <digetx@gmail.com>
 *
 *  This program is free software; you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by the
 *  Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful, but WITHOUT
 *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 *  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
 *  for more details.
 *
 *  You should have received a copy of the GNU General Public License along
 *  with this program; if not, see <http://www.gnu.org/licenses/>.
 */

#define CONFIG_ARCH_TEGRA_21x_SOC

#include "tegra_common.h"

#include "hw/sysbus.h"

#include "mc.h"
#include "iomap.h"
#include "tegra_trace.h"
#include "devices.h"

#define TYPE_TEGRA_MC "tegra.mc"
#define TEGRA_MC(obj) OBJECT_CHECK(tegra_mc, (obj), TYPE_TEGRA_MC)
#define DEFINE_REG32(reg) reg##_t reg
#define WR_MASKED(r, d, m)  r = (r & ~m##_WRMASK) | (d & m##_WRMASK)

typedef struct tegra_mc_state {
    SysBusDevice parent_obj;

    uint32_t ram_size_kb;
    MemoryRegion iomem;
    uint32_t emem_cfg_offset;
    uint32_t emem_adr_cfg_offset;
    DEFINE_REG32(emem_cfg);
    DEFINE_REG32(err_status);
    DEFINE_REG32(smmu_config);
    DEFINE_REG32(emem_adr_cfg);
    DEFINE_REG32(emem_arb_cfg0);
    DEFINE_REG32(emem_arb_cfg1);
    DEFINE_REG32(emem_arb_cfg2);
    DEFINE_REG32(gart_config);
    DEFINE_REG32(gart_entry_addr);
    DEFINE_REG32(gart_entry_data);
    DEFINE_REG32(gart_error_req);
    DEFINE_REG32(gart_error_addr);
    DEFINE_REG32(timeout_ctrl);
    DEFINE_REG32(decerr_emem_others_status);
    DEFINE_REG32(decerr_emem_others_adr);
    DEFINE_REG32(client_ctrl);
    DEFINE_REG32(client_hotresetn);
    DEFINE_REG32(lowlatency_rawlogic_write_participants);
    DEFINE_REG32(bwshare_tmval);
    DEFINE_REG32(bwshare_emem_ctrl_0);
    DEFINE_REG32(bwshare_emem_ctrl_1);
    DEFINE_REG32(avpc_orrc);
    DEFINE_REG32(dc_orrc);
    DEFINE_REG32(dcb_orrc);
    DEFINE_REG32(epp_orrc);
    DEFINE_REG32(g2_orrc);
    DEFINE_REG32(hc_orrc);
    DEFINE_REG32(isp_orrc);
    DEFINE_REG32(mpcore_orrc);
    DEFINE_REG32(mpea_orrc);
    DEFINE_REG32(mpeb_orrc);
    DEFINE_REG32(mpec_orrc);
    DEFINE_REG32(nv_orrc);
    DEFINE_REG32(ppcs_orrc);
    DEFINE_REG32(vde_orrc);
    DEFINE_REG32(vi_orrc);
    DEFINE_REG32(fpri_ctrl_avpc);
    DEFINE_REG32(fpri_ctrl_dc);
    DEFINE_REG32(fpri_ctrl_dcb);
    DEFINE_REG32(fpri_ctrl_epp);
    DEFINE_REG32(fpri_ctrl_g2);
    DEFINE_REG32(fpri_ctrl_hc);
    DEFINE_REG32(fpri_ctrl_isp);
    DEFINE_REG32(fpri_ctrl_mpcore);
    DEFINE_REG32(fpri_ctrl_mpea);
    DEFINE_REG32(fpri_ctrl_mpeb);
    DEFINE_REG32(fpri_ctrl_mpec);
    DEFINE_REG32(fpri_ctrl_nv);
    DEFINE_REG32(fpri_ctrl_ppcs);
    DEFINE_REG32(fpri_ctrl_vde);
    DEFINE_REG32(fpri_ctrl_vi);
    DEFINE_REG32(timeout_avpc);
    DEFINE_REG32(timeout_dc);
    DEFINE_REG32(timeout_dcb);
    DEFINE_REG32(timeout_epp);
    DEFINE_REG32(timeout_g2);
    DEFINE_REG32(timeout_hc);
    DEFINE_REG32(timeout_isp);
    DEFINE_REG32(timeout_mpcore);
    DEFINE_REG32(timeout_mpea);
    DEFINE_REG32(timeout_mpeb);
    DEFINE_REG32(timeout_mpec);
    DEFINE_REG32(timeout_nv);
    DEFINE_REG32(timeout_ppcs);
    DEFINE_REG32(timeout_vde);
    DEFINE_REG32(timeout_vi);
    DEFINE_REG32(timeout_rcoal_avpc);
    DEFINE_REG32(timeout_rcoal_dc);
    DEFINE_REG32(timeout1_rcoal_dc);
    DEFINE_REG32(timeout_rcoal_dcb);
    DEFINE_REG32(timeout1_rcoal_dcb);
    DEFINE_REG32(timeout_rcoal_epp);
    DEFINE_REG32(timeout_rcoal_g2);
    DEFINE_REG32(timeout_rcoal_hc);
    DEFINE_REG32(timeout_rcoal_mpcore);
    DEFINE_REG32(timeout_rcoal_mpea);
    DEFINE_REG32(timeout_rcoal_mpeb);
    DEFINE_REG32(timeout_rcoal_mpec);
    DEFINE_REG32(timeout_rcoal_nv);
    DEFINE_REG32(timeout_rcoal_ppcs);
    DEFINE_REG32(timeout_rcoal_vde);
    DEFINE_REG32(timeout_rcoal_vi);
    DEFINE_REG32(rcoal_autodisable);
    DEFINE_REG32(bwshare_avpc);
    DEFINE_REG32(bwshare_dc);
    DEFINE_REG32(bwshare_dcb);
    DEFINE_REG32(bwshare_epp);
    DEFINE_REG32(bwshare_g2);
    DEFINE_REG32(bwshare_hc);
    DEFINE_REG32(bwshare_isp);
    DEFINE_REG32(bwshare_mpcore);
    DEFINE_REG32(bwshare_mpea);
    DEFINE_REG32(bwshare_mpeb);
    DEFINE_REG32(bwshare_mpec);
    DEFINE_REG32(bwshare_nv);
    DEFINE_REG32(bwshare_ppcs);
    DEFINE_REG32(bwshare_vde);
    DEFINE_REG32(bwshare_vi);
    DEFINE_REG32(intstatus);
    DEFINE_REG32(intmask);
    DEFINE_REG32(clken_override);
    DEFINE_REG32(security_cfg0);
    DEFINE_REG32(security_cfg1);
    DEFINE_REG32(security_violation_status);
    DEFINE_REG32(security_violation_adr);
    DEFINE_REG32(security_cfg2);
    DEFINE_REG32(stat_control);
    DEFINE_REG32(stat_status);
    DEFINE_REG32(stat_emc_addr_low);
    DEFINE_REG32(stat_emc_addr_high);
    DEFINE_REG32(stat_emc_clock_limit);
    DEFINE_REG32(stat_emc_clocks);
    DEFINE_REG32(stat_emc_control_0);
    DEFINE_REG32(stat_emc_control_1);
    DEFINE_REG32(stat_emc_hist_limit_0);
    DEFINE_REG32(stat_emc_hist_limit_1);
    DEFINE_REG32(stat_emc_count_0);
    DEFINE_REG32(stat_emc_count_1);
    DEFINE_REG32(stat_emc_hist_0);
    DEFINE_REG32(stat_emc_hist_1);
    DEFINE_REG32(axi_decerr_ovr);
    DEFINE_REG32(lowlatency_config);
    DEFINE_REG32(ap_ctrl_0);
    DEFINE_REG32(ap_ctrl_1);
    DEFINE_REG32(client_activity_monitor_emem_0);
    DEFINE_REG32(client_activity_monitor_emem_1);
    uint32_t regs[TEGRA_MC_SIZE>>2];
} tegra_mc;

static const VMStateDescription vmstate_tegra_mc = {
    .name = "tegra.mc",
    .version_id = 1,
    .minimum_version_id = 1,
    .fields = (VMStateField[]) {
        VMSTATE_UINT32(emem_cfg_offset, tegra_mc),
        VMSTATE_UINT32(emem_adr_cfg_offset, tegra_mc),
        VMSTATE_UINT32(err_status.reg32, tegra_mc),
        VMSTATE_UINT32(emem_cfg.reg32, tegra_mc),
        VMSTATE_UINT32(smmu_config.reg32, tegra_mc),
        VMSTATE_UINT32(emem_adr_cfg.reg32, tegra_mc),
        VMSTATE_UINT32(emem_arb_cfg0.reg32, tegra_mc),
        VMSTATE_UINT32(emem_arb_cfg1.reg32, tegra_mc),
        VMSTATE_UINT32(emem_arb_cfg2.reg32, tegra_mc),
        VMSTATE_UINT32(gart_config.reg32, tegra_mc),
        VMSTATE_UINT32(gart_entry_addr.reg32, tegra_mc),
        VMSTATE_UINT32(gart_entry_data.reg32, tegra_mc),
        VMSTATE_UINT32(gart_error_req.reg32, tegra_mc),
        VMSTATE_UINT32(gart_error_addr.reg32, tegra_mc),
        VMSTATE_UINT32(timeout_ctrl.reg32, tegra_mc),
        VMSTATE_UINT32(decerr_emem_others_status.reg32, tegra_mc),
        VMSTATE_UINT32(decerr_emem_others_adr.reg32, tegra_mc),
        VMSTATE_UINT32(client_ctrl.reg32, tegra_mc),
        VMSTATE_UINT32(client_hotresetn.reg32, tegra_mc),
        VMSTATE_UINT32(lowlatency_rawlogic_write_participants.reg32, tegra_mc),
        VMSTATE_UINT32(bwshare_tmval.reg32, tegra_mc),
        VMSTATE_UINT32(bwshare_emem_ctrl_0.reg32, tegra_mc),
        VMSTATE_UINT32(bwshare_emem_ctrl_1.reg32, tegra_mc),
        VMSTATE_UINT32(avpc_orrc.reg32, tegra_mc),
        VMSTATE_UINT32(dc_orrc.reg32, tegra_mc),
        VMSTATE_UINT32(dcb_orrc.reg32, tegra_mc),
        VMSTATE_UINT32(epp_orrc.reg32, tegra_mc),
        VMSTATE_UINT32(g2_orrc.reg32, tegra_mc),
        VMSTATE_UINT32(hc_orrc.reg32, tegra_mc),
        VMSTATE_UINT32(isp_orrc.reg32, tegra_mc),
        VMSTATE_UINT32(mpcore_orrc.reg32, tegra_mc),
        VMSTATE_UINT32(mpea_orrc.reg32, tegra_mc),
        VMSTATE_UINT32(mpeb_orrc.reg32, tegra_mc),
        VMSTATE_UINT32(mpec_orrc.reg32, tegra_mc),
        VMSTATE_UINT32(nv_orrc.reg32, tegra_mc),
        VMSTATE_UINT32(ppcs_orrc.reg32, tegra_mc),
        VMSTATE_UINT32(vde_orrc.reg32, tegra_mc),
        VMSTATE_UINT32(vi_orrc.reg32, tegra_mc),
        VMSTATE_UINT32(fpri_ctrl_avpc.reg32, tegra_mc),
        VMSTATE_UINT32(fpri_ctrl_dc.reg32, tegra_mc),
        VMSTATE_UINT32(fpri_ctrl_dcb.reg32, tegra_mc),
        VMSTATE_UINT32(fpri_ctrl_epp.reg32, tegra_mc),
        VMSTATE_UINT32(fpri_ctrl_g2.reg32, tegra_mc),
        VMSTATE_UINT32(fpri_ctrl_hc.reg32, tegra_mc),
        VMSTATE_UINT32(fpri_ctrl_isp.reg32, tegra_mc),
        VMSTATE_UINT32(fpri_ctrl_mpcore.reg32, tegra_mc),
        VMSTATE_UINT32(fpri_ctrl_mpea.reg32, tegra_mc),
        VMSTATE_UINT32(fpri_ctrl_mpeb.reg32, tegra_mc),
        VMSTATE_UINT32(fpri_ctrl_mpec.reg32, tegra_mc),
        VMSTATE_UINT32(fpri_ctrl_nv.reg32, tegra_mc),
        VMSTATE_UINT32(fpri_ctrl_ppcs.reg32, tegra_mc),
        VMSTATE_UINT32(fpri_ctrl_vde.reg32, tegra_mc),
        VMSTATE_UINT32(fpri_ctrl_vi.reg32, tegra_mc),
        VMSTATE_UINT32(timeout_avpc.reg32, tegra_mc),
        VMSTATE_UINT32(timeout_dc.reg32, tegra_mc),
        VMSTATE_UINT32(timeout_dcb.reg32, tegra_mc),
        VMSTATE_UINT32(timeout_epp.reg32, tegra_mc),
        VMSTATE_UINT32(timeout_g2.reg32, tegra_mc),
        VMSTATE_UINT32(timeout_hc.reg32, tegra_mc),
        VMSTATE_UINT32(timeout_isp.reg32, tegra_mc),
        VMSTATE_UINT32(timeout_mpcore.reg32, tegra_mc),
        VMSTATE_UINT32(timeout_mpea.reg32, tegra_mc),
        VMSTATE_UINT32(timeout_mpeb.reg32, tegra_mc),
        VMSTATE_UINT32(timeout_mpec.reg32, tegra_mc),
        VMSTATE_UINT32(timeout_nv.reg32, tegra_mc),
        VMSTATE_UINT32(timeout_ppcs.reg32, tegra_mc),
        VMSTATE_UINT32(timeout_vde.reg32, tegra_mc),
        VMSTATE_UINT32(timeout_vi.reg32, tegra_mc),
        VMSTATE_UINT32(timeout_rcoal_avpc.reg32, tegra_mc),
        VMSTATE_UINT32(timeout_rcoal_dc.reg32, tegra_mc),
        VMSTATE_UINT32(timeout1_rcoal_dc.reg32, tegra_mc),
        VMSTATE_UINT32(timeout_rcoal_dcb.reg32, tegra_mc),
        VMSTATE_UINT32(timeout1_rcoal_dcb.reg32, tegra_mc),
        VMSTATE_UINT32(timeout_rcoal_epp.reg32, tegra_mc),
        VMSTATE_UINT32(timeout_rcoal_g2.reg32, tegra_mc),
        VMSTATE_UINT32(timeout_rcoal_hc.reg32, tegra_mc),
        VMSTATE_UINT32(timeout_rcoal_mpcore.reg32, tegra_mc),
        VMSTATE_UINT32(timeout_rcoal_mpea.reg32, tegra_mc),
        VMSTATE_UINT32(timeout_rcoal_mpeb.reg32, tegra_mc),
        VMSTATE_UINT32(timeout_rcoal_mpec.reg32, tegra_mc),
        VMSTATE_UINT32(timeout_rcoal_nv.reg32, tegra_mc),
        VMSTATE_UINT32(timeout_rcoal_ppcs.reg32, tegra_mc),
        VMSTATE_UINT32(timeout_rcoal_vde.reg32, tegra_mc),
        VMSTATE_UINT32(timeout_rcoal_vi.reg32, tegra_mc),
        VMSTATE_UINT32(rcoal_autodisable.reg32, tegra_mc),
        VMSTATE_UINT32(bwshare_avpc.reg32, tegra_mc),
        VMSTATE_UINT32(bwshare_dc.reg32, tegra_mc),
        VMSTATE_UINT32(bwshare_dcb.reg32, tegra_mc),
        VMSTATE_UINT32(bwshare_epp.reg32, tegra_mc),
        VMSTATE_UINT32(bwshare_g2.reg32, tegra_mc),
        VMSTATE_UINT32(bwshare_hc.reg32, tegra_mc),
        VMSTATE_UINT32(bwshare_isp.reg32, tegra_mc),
        VMSTATE_UINT32(bwshare_mpcore.reg32, tegra_mc),
        VMSTATE_UINT32(bwshare_mpea.reg32, tegra_mc),
        VMSTATE_UINT32(bwshare_mpeb.reg32, tegra_mc),
        VMSTATE_UINT32(bwshare_mpec.reg32, tegra_mc),
        VMSTATE_UINT32(bwshare_nv.reg32, tegra_mc),
        VMSTATE_UINT32(bwshare_ppcs.reg32, tegra_mc),
        VMSTATE_UINT32(bwshare_vde.reg32, tegra_mc),
        VMSTATE_UINT32(bwshare_vi.reg32, tegra_mc),
        VMSTATE_UINT32(intstatus.reg32, tegra_mc),
        VMSTATE_UINT32(intmask.reg32, tegra_mc),
        VMSTATE_UINT32(clken_override.reg32, tegra_mc),
        VMSTATE_UINT32(security_cfg0.reg32, tegra_mc),
        VMSTATE_UINT32(security_cfg1.reg32, tegra_mc),
        VMSTATE_UINT32(security_violation_status.reg32, tegra_mc),
        VMSTATE_UINT32(security_violation_adr.reg32, tegra_mc),
        VMSTATE_UINT32(security_cfg2.reg32, tegra_mc),
        VMSTATE_UINT32(stat_control.reg32, tegra_mc),
        VMSTATE_UINT32(stat_status.reg32, tegra_mc),
        VMSTATE_UINT32(stat_emc_addr_low.reg32, tegra_mc),
        VMSTATE_UINT32(stat_emc_addr_high.reg32, tegra_mc),
        VMSTATE_UINT32(stat_emc_clock_limit.reg32, tegra_mc),
        VMSTATE_UINT32(stat_emc_clocks.reg32, tegra_mc),
        VMSTATE_UINT32(stat_emc_control_0.reg32, tegra_mc),
        VMSTATE_UINT32(stat_emc_control_1.reg32, tegra_mc),
        VMSTATE_UINT32(stat_emc_hist_limit_0.reg32, tegra_mc),
        VMSTATE_UINT32(stat_emc_hist_limit_1.reg32, tegra_mc),
        VMSTATE_UINT32(stat_emc_count_0.reg32, tegra_mc),
        VMSTATE_UINT32(stat_emc_count_1.reg32, tegra_mc),
        VMSTATE_UINT32(stat_emc_hist_0.reg32, tegra_mc),
        VMSTATE_UINT32(stat_emc_hist_1.reg32, tegra_mc),
        VMSTATE_UINT32(axi_decerr_ovr.reg32, tegra_mc),
        VMSTATE_UINT32(lowlatency_config.reg32, tegra_mc),
        VMSTATE_UINT32(ap_ctrl_0.reg32, tegra_mc),
        VMSTATE_UINT32(ap_ctrl_1.reg32, tegra_mc),
        VMSTATE_UINT32(client_activity_monitor_emem_0.reg32, tegra_mc),
        VMSTATE_UINT32(client_activity_monitor_emem_1.reg32, tegra_mc),
        VMSTATE_UINT32_ARRAY(regs, tegra_mc, TEGRA_MC_SIZE>>2),
        VMSTATE_END_OF_LIST()
    }
};

static uint32_t tegra_mc_regdef_tegrax1_reset_table[] = {
    TEGRA_REGDEF_TABLE_RESET(MC_INTSTATUS_0, 0x0, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_INTMASK_0, 0x4, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_ERR_STATUS_0, 0x8, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_ERR_ADR_0, 0xC, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_SMMU_CONFIG_0, 0x10, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_SMMU_TLB_CONFIG_0, 0x14, 0x30000030)
    TEGRA_REGDEF_TABLE_RESET(MC_SMMU_PTC_CONFIG_0, 0x18, 0x28000F3F)
    TEGRA_REGDEF_TABLE_RESET(MC_SMMU_PTB_ASID_0, 0x1C, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_SMMU_PTB_DATA_0, 0x20, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_SMMU_TLB_FLUSH_0, 0x30, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_SMMU_PTC_FLUSH_0, 0x34, 0x00000008)
    TEGRA_REGDEF_TABLE_RESET(MC_EMEM_CFG_0, 0x50, 0x00002000)
    TEGRA_REGDEF_TABLE_RESET(MC_EMEM_ADR_CFG_0, 0x54, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_EMEM_ADR_CFG_DEV0_0, 0x58, 0x00040202)
    TEGRA_REGDEF_TABLE_RESET(MC_EMEM_ADR_CFG_DEV1_0, 0x5C, 0x00040202)
    TEGRA_REGDEF_TABLE_RESET(MC_EMEM_ADR_CFG_CHANNEL_MASK_0, 0x60, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_EMEM_ADR_CFG_BANK_MASK_0_0, 0x64, 0xEB772400)
    TEGRA_REGDEF_TABLE_RESET(MC_EMEM_ADR_CFG_BANK_MASK_1_0, 0x68, 0x249E4800)
    TEGRA_REGDEF_TABLE_RESET(MC_EMEM_ADR_CFG_BANK_MASK_2_0, 0x6C, 0x9DBBB000)
    TEGRA_REGDEF_TABLE_RESET(MC_SECURITY_CFG0_0, 0x70, 0x80000000)
    TEGRA_REGDEF_TABLE_RESET(MC_SECURITY_CFG1_0, 0x74, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_EMEM_ARB_CFG_0, 0x90, 0x00000008)
    TEGRA_REGDEF_TABLE_RESET(MC_EMEM_ARB_OUTSTANDING_REQ_0, 0x94, 0x80000040)
    TEGRA_REGDEF_TABLE_RESET(MC_EMEM_ARB_TIMING_RCD_0, 0x98, 0x0000003F)
    TEGRA_REGDEF_TABLE_RESET(MC_EMEM_ARB_TIMING_RP_0, 0x9C, 0x0000007F)
    TEGRA_REGDEF_TABLE_RESET(MC_EMEM_ARB_TIMING_RC_0, 0xA0, 0x000000FF)
    TEGRA_REGDEF_TABLE_RESET(MC_EMEM_ARB_TIMING_RAS_0, 0xA4, 0x0000007F)
    TEGRA_REGDEF_TABLE_RESET(MC_EMEM_ARB_TIMING_FAW_0, 0xA8, 0x0000007F)
    TEGRA_REGDEF_TABLE_RESET(MC_EMEM_ARB_TIMING_RRD_0, 0xAC, 0x0000001F)
    TEGRA_REGDEF_TABLE_RESET(MC_EMEM_ARB_TIMING_RAP2PRE_0, 0xB0, 0x0000007F)
    TEGRA_REGDEF_TABLE_RESET(MC_EMEM_ARB_TIMING_WAP2PRE_0, 0xB4, 0x0000007F)
    TEGRA_REGDEF_TABLE_RESET(MC_EMEM_ARB_TIMING_R2R_0, 0xB8, 0x0000001F)
    TEGRA_REGDEF_TABLE_RESET(MC_EMEM_ARB_TIMING_W2W_0, 0xBC, 0x0000001F)
    TEGRA_REGDEF_TABLE_RESET(MC_EMEM_ARB_TIMING_R2W_0, 0xC0, 0x0000007F)
    TEGRA_REGDEF_TABLE_RESET(MC_EMEM_ARB_TIMING_W2R_0, 0xC4, 0x0000007F)
    TEGRA_REGDEF_TABLE_RESET(MC_EMEM_ARB_DA_TURNS_0, 0xD0, 0x0F0F0205)
    TEGRA_REGDEF_TABLE_RESET(MC_EMEM_ARB_DA_COVERS_0, 0xD4, 0x000F0F0F)
    TEGRA_REGDEF_TABLE_RESET(MC_EMEM_ARB_MISC0_0, 0xD8, 0x720A4010)
    TEGRA_REGDEF_TABLE_RESET(MC_EMEM_DVFS_CNTR_CFG_RESET., 0xDC, 0x80A0000A)
    TEGRA_REGDEF_TABLE_RESET(MC_EMEM_ARB_MISC2_0, 0xC8, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_EMEM_ARB_RING1_THROTTLE_0, 0xE0, 0x001F0000)
    TEGRA_REGDEF_TABLE_RESET(MC_EMEM_ARB_RING3_THROTTLE_0, 0xE4, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_EMEM_ARB_OVERRIDE_0, 0xE8, 0x10000000)
    TEGRA_REGDEF_TABLE_RESET(MC_EMEM_ARB_RSV_0, 0xEC, 0xFF00FF00)
    TEGRA_REGDEF_TABLE_RESET(MC_CLKEN_OVERRIDE_0, 0xF4, 0x00008000)
    TEGRA_REGDEF_TABLE_RESET(MC_TIMING_CONTROL_0, 0xFC, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_STAT_CONTROL_0, 0x100, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_PM_STOP_TRIGGER:, 0x200, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_CLIENT_HOTRESET_STATUS_0, 0x204, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_EMEM_ARB_ISOCHRONOUS_0_0, 0x208, 0x0023007E)
    TEGRA_REGDEF_TABLE_RESET(MC_EMEM_ARB_ISOCHRONOUS_1_0, 0x20C, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_EMEM_ARB_ISOCHRONOUS_2_0, 0x210, 0x04000000)
    TEGRA_REGDEF_TABLE_RESET(MC_EMEM_ARB_ISOCHRONOUS_3_0, 0x214, 0x00080000)
    TEGRA_REGDEF_TABLE_RESET(MC_EMEM_ARB_HYSTERESIS_0_0, 0x218, 0x0003007E)
    TEGRA_REGDEF_TABLE_RESET(MC_EMEM_ARB_HYSTERESIS_1_0, 0x21C, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_EMEM_ARB_HYSTERESIS_2_0, 0x220, 0x04000000)
    TEGRA_REGDEF_TABLE_RESET(MC_EMEM_ARB_HYSTERESIS_3_0, 0x224, 0x00080000)
    TEGRA_REGDEF_TABLE_RESET(MC_SMMU_TRANSLATION_ENABLE_0_0, 0x228, 0xF0E3C07E)
    TEGRA_REGDEF_TABLE_RESET(MC_SMMU_TRANSLATION_ENABLE_1_0, 0x22C, 0x38660800)
    TEGRA_REGDEF_TABLE_RESET(MC_SMMU_TRANSLATION_ENABLE_2_0, 0x230, 0x04F37CD0)
    TEGRA_REGDEF_TABLE_RESET(MC_SMMU_TRANSLATION_ENABLE_3_0, 0x234, 0xCF0C30FF)
    TEGRA_REGDEF_TABLE_RESET(MC_SMMU_AFI_ASID_0, 0x238, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_SMMU_AVPC_ASID_0, 0x23C, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_SMMU_DC_ASID_0, 0x240, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_SMMU_DCB_ASID_0, 0x244, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_SMMU_HC_ASID_0, 0x250, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_SMMU_HDA_ASID_0, 0x254, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_SMMU_ISP2_ASID_0, 0x258, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_SMMU_NVENC_ASID_0, 0x264, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_SMMU_NV_ASID_0, 0x268, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_SMMU_NV2_ASID_0, 0x26C, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_SMMU_PPCS_ASID_0, 0x270, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_SMMU_SATA_ASID_0, 0x274, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_SMMU_VI_ASID_0, 0x280, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_SMMU_VIC_ASID_0, 0x284, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_SMMU_XUSB_HOST_ASID_0, 0x288, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_SMMU_XUSB_DEV_ASID_0, 0x28C, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_SMMU_TSEC_ASID_0, 0x294, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_SMMU_PPCS1_ASID_0, 0x298, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_VIDEO_PROTECT_VPR_OVERRIDE_0, 0x418, 0xE4BAC343)
    TEGRA_REGDEF_TABLE_RESET(MC_VIDEO_PROTECT_VPR_OVERRIDE1_0, 0x590, 0x00001ED3)
    TEGRA_REGDEF_TABLE_RESET(MC_SMMU_TLB_SET_SELECTION_MASK_0_0, 0x600, 0x00008000)
    TEGRA_REGDEF_TABLE_RESET(MC_DISPLAY_SNAP_RING_0, 0x608, 0x00000003)
    TEGRA_REGDEF_TABLE_RESET(MC_ERR_VPR_STATUS_0, 0x654, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_ERR_VPR_ADR_0, 0x658, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_IRAM_REG_CTRL_0, 0x964, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_EMEM_CFG_ACCESS_CTRL_0, 0x664, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_TZ_SECURITY_CTRL_0, 0x668, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_EMEM_ARB_OUTSTANDING_REQ_RING3_0, 0x66C, 0x80000080)
    TEGRA_REGDEF_TABLE_RESET(MC_SEC_CARVEOUT_BOM_0, 0x670, 0xFFF00000)
    TEGRA_REGDEF_TABLE_RESET(MC_SEC_CARVEOUT_SIZE_MB_0, 0x674, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_SEC_CARVEOUT_REG_CTRL_0, 0x678, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_ERR_SEC_STATUS_0, 0x67C, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_ERR_SEC_ADR_0, 0x680, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_PC_IDLE_CLOCK_GATE_CONFIG_0, 0x684, 0x0000001F)
    TEGRA_REGDEF_TABLE_RESET(MC_STUTTER_CONTROL_0, 0x688, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_EMEM_ARB_NISO_THROTTLE_0, 0x6B0, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_EMEM_ARB_OUTSTANDING_REQ_NISO_0, 0x6B4, 0x80000080)
    TEGRA_REGDEF_TABLE_RESET(MC_EMEM_ARB_NISO_THROTTLE_MASK_0, 0x6B8, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_EMEM_ARB_RING0_THROTTLE_MASK_0, 0x6BC, 0x80008041)
    TEGRA_REGDEF_TABLE_RESET(MC_EMEM_ARB_TIMING_RFCPB_0, 0x6C0, 0x0000007F)
    TEGRA_REGDEF_TABLE_RESET(MC_EMEM_ARB_TIMING_CCDMW_0, 0x6C4, 0x00000001)
    TEGRA_REGDEF_TABLE_RESET(MC_EMEM_ARB_REFPB_HP_CTRL_0, 0x6F0, 0x000A1020)
    TEGRA_REGDEF_TABLE_RESET(MC_EMEM_ARB_REFPB_BANK_CTRL_0, 0x6F4, 0x00002636)
    TEGRA_REGDEF_TABLE_RESET(MC_EMEM_ARB_OVERRIDE_1_0, 0x968, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_CLIENT_HOTRESET_CTRL_1_0, 0x970, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_CLIENT_HOTRESET_STATUS_1_0, 0x974, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_VIDEO_PROTECT_GPU_OVERRIDE_0_0, 0x984, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_VIDEO_PROTECT_GPU_OVERRIDE_1_0, 0x988, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_SMMU_PTC_FLUSH_1_0, 0x9B8, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_SECURITY_CFG3_0, 0x9BC, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_EMEM_BANK_SWIZZLE_CFG0_0, 0x9C0, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_EMEM_BANK_SWIZZLE_CFG1_0, 0x9C4, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_EMEM_BANK_SWIZZLE_CFG2_0, 0x9C8, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_EMEM_BANK_SWIZZLE_CFG3_0, 0x9CC, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_SEC_CARVEOUT_ADR_HI_0, 0x9D4, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_SMMU_DC1_ASID_0, 0xA88, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_SMMU_SDMMC1A_ASID_0, 0xA94, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_SMMU_SDMMC2A_ASID_0, 0xA98, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_SMMU_SDMMC3A_ASID_0, 0xA9C, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_SMMU_SDMMC4A_ASID_0, 0xAA0, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_SMMU_ISP2B_ASID_0, 0xAA4, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_SMMU_GPU_ASID_0, 0xAA8, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_SMMU_GPUB_ASID_0, 0xAAC, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_SMMU_PPCS2_ASID_0, 0xAB0, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_SMMU_NVDEC_ASID_0, 0xAB4, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_SMMU_APE_ASID_0, 0xAB8, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_SMMU_SE_ASID_0, 0xABC, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_SMMU_NVJPG_ASID_0, 0xAC0, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_SMMU_HC1_ASID_0, 0xAC4, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_SMMU_SE1_ASID_0, 0xAC8, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_SMMU_AXIAP_ASID_0, 0xACC, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_SMMU_ETR_ASID_0, 0xAD0, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_SMMU_TSECB_ASID_0, 0xAD4, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_SMMU_TSEC1_ASID_0, 0xAD8, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_SMMU_TSECB1_ASID_0, 0xADC, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_SMMU_NVDEC1_ASID_0, 0xAE0, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_EMEM_ARB_NISO_THROTTLE_MASK_1_0, 0xB80, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_EMEM_ARB_HYSTERESIS_4_0, 0xB84, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_EMEM_ARB_ISOCHRONOUS_4_0, 0xB94, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_SMMU_TRANSLATION_ENABLE_4_0, 0xB98, 0x000000FF)
    TEGRA_REGDEF_TABLE_RESET(MC_EMEM_ARB_DHYSTERESIS_0_0, 0xBB0, 0x10000000)
    TEGRA_REGDEF_TABLE_RESET(MC_EMEM_ARB_DHYSTERESIS_1_0, 0xBB4, 0x00000800)
    TEGRA_REGDEF_TABLE_RESET(MC_EMEM_ARB_DHYSTERESIS_2_0, 0xBB8, 0x030340D0)
    TEGRA_REGDEF_TABLE_RESET(MC_EMEM_ARB_DHYSTERESIS_3_0, 0xBBC, 0xC3043000)
    TEGRA_REGDEF_TABLE_RESET(MC_EMEM_ARB_DHYSTERESIS_4_0, 0xBC0, 0x00000300)
    TEGRA_REGDEF_TABLE_RESET(MC_EMEM_ARB_DHYST_CTRL_0, 0xBCC, 0x00000002)
    TEGRA_REGDEF_TABLE_RESET(MC_EMEM_ARB_DHYST_TIMEOUT_UTIL_0_0, 0xBD0, 0x00000100)
    TEGRA_REGDEF_TABLE_RESET(MC_EMEM_ARB_DHYST_TIMEOUT_UTIL_1_0, 0xBD4, 0x000000A0)
    TEGRA_REGDEF_TABLE_RESET(MC_EMEM_ARB_DHYST_TIMEOUT_UTIL_2_0, 0xBD8, 0x00000060)
    TEGRA_REGDEF_TABLE_RESET(MC_EMEM_ARB_DHYST_TIMEOUT_UTIL_3_0, 0xBDC, 0x00000034)
    TEGRA_REGDEF_TABLE_RESET(MC_EMEM_ARB_DHYST_TIMEOUT_UTIL_4_0, 0xBE0, 0x00000018)
    TEGRA_REGDEF_TABLE_RESET(MC_EMEM_ARB_DHYST_TIMEOUT_UTIL_5_0, 0xBE4, 0x0000000C)
    TEGRA_REGDEF_TABLE_RESET(MC_EMEM_ARB_DHYST_TIMEOUT_UTIL_6_0, 0xBE8, 0x00000004)
    TEGRA_REGDEF_TABLE_RESET(MC_EMEM_ARB_DHYST_TIMEOUT_UTIL_7_0, 0xBEC, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_DA_CONFIG0_0, 0x9DC, 0x00000001)
    TEGRA_REGDEF_TABLE_RESET(MC_AHB_PTSA_MIN_0, 0x4E0, 0x0000003F)
    TEGRA_REGDEF_TABLE_RESET(MC_AUD_PTSA_MIN_0, 0x54C, 0x0000003F)
    TEGRA_REGDEF_TABLE_RESET(MC_MLL_MPCORER_PTSA_RATE_0, 0x44C, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_RING2_PTSA_RATE_0, 0x440, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_USBD_PTSA_RATE_0, 0x530, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_USBX_PTSA_MIN_0, 0x528, 0x0000003F)
    TEGRA_REGDEF_TABLE_RESET(MC_USBD_PTSA_MIN_0, 0x534, 0x0000003F)
    TEGRA_REGDEF_TABLE_RESET(MC_APB_PTSA_MAX_0, 0x4F0, 0x0000003F)
    TEGRA_REGDEF_TABLE_RESET(MC_JPG_PTSA_RATE_0, 0x584, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_DIS_PTSA_MIN_0, 0x420, 0x0000003F)
    TEGRA_REGDEF_TABLE_RESET(MC_AVP_PTSA_MAX_0, 0x4FC, 0x0000003F)
    TEGRA_REGDEF_TABLE_RESET(MC_AVP_PTSA_RATE_0, 0x4F4, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_RING1_PTSA_MIN_0, 0x480, 0x0000003F)
    TEGRA_REGDEF_TABLE_RESET(MC_DIS_PTSA_MAX_0, 0x424, 0x0000003F)
    TEGRA_REGDEF_TABLE_RESET(MC_SD_PTSA_MAX_0, 0x4D8, 0x0000003F)
    TEGRA_REGDEF_TABLE_RESET(MC_MSE_PTSA_RATE_0, 0x4C4, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_VICPC_PTSA_MIN_0, 0x558, 0x0000003F)
    TEGRA_REGDEF_TABLE_RESET(MC_PCX_PTSA_MAX_0, 0x4B4, 0x0000003F)
    TEGRA_REGDEF_TABLE_RESET(MC_ISP_PTSA_RATE_0, 0x4A0, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_A9AVPPC_PTSA_MIN_0, 0x48C, 0x0000003F)
    TEGRA_REGDEF_TABLE_RESET(MC_RING2_PTSA_MAX_0, 0x448, 0x0000003F)
    TEGRA_REGDEF_TABLE_RESET(MC_AUD_PTSA_RATE_0, 0x548, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_HOST_PTSA_MIN_0, 0x51C, 0x0000003F)
    TEGRA_REGDEF_TABLE_RESET(MC_MLL_MPCORER_PTSA_MAX_0, 0x454, 0x0000003F)
    TEGRA_REGDEF_TABLE_RESET(MC_SD_PTSA_MIN_0, 0x4D4, 0x0000003F)
    TEGRA_REGDEF_TABLE_RESET(MC_RING1_PTSA_RATE_0, 0x47C, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_JPG_PTSA_MIN_0, 0x588, 0x0000003F)
    TEGRA_REGDEF_TABLE_RESET(MC_HDAPC_PTSA_MIN_0, 0x62C, 0x0000003F)
    TEGRA_REGDEF_TABLE_RESET(MC_AVP_PTSA_MIN_0, 0x4F8, 0x0000003F)
    TEGRA_REGDEF_TABLE_RESET(MC_JPG_PTSA_MAX_0, 0x58C, 0x0000003F)
    TEGRA_REGDEF_TABLE_RESET(MC_VE_PTSA_MAX_0, 0x43C, 0x0000003F)
    TEGRA_REGDEF_TABLE_RESET(MC_DFD_PTSA_MAX_0, 0x63C, 0x0000003F)
    TEGRA_REGDEF_TABLE_RESET(MC_VICPC_PTSA_RATE_0, 0x554, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_GK_PTSA_MAX_0, 0x544, 0x0000003F)
    TEGRA_REGDEF_TABLE_RESET(MC_VICPC_PTSA_MAX_0, 0x55C, 0x0000003F)
    TEGRA_REGDEF_TABLE_RESET(MC_SDM_PTSA_MAX_0, 0x624, 0x0000003F)
    TEGRA_REGDEF_TABLE_RESET(MC_SAX_PTSA_RATE_0, 0x4B8, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_PCX_PTSA_MIN_0, 0x4B0, 0x0000003F)
    TEGRA_REGDEF_TABLE_RESET(MC_APB_PTSA_MIN_0, 0x4EC, 0x0000003F)
    TEGRA_REGDEF_TABLE_RESET(MC_GK2_PTSA_MIN_0, 0x614, 0x0000003F)
    TEGRA_REGDEF_TABLE_RESET(MC_PCX_PTSA_RATE_0, 0x4AC, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_RING1_PTSA_MAX_0, 0x484, 0x0000003F)
    TEGRA_REGDEF_TABLE_RESET(MC_HDAPC_PTSA_RATE_0, 0x628, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_MLL_MPCORER_PTSA_MIN_0, 0x450, 0x0000003F)
    TEGRA_REGDEF_TABLE_RESET(MC_GK2_PTSA_MAX_0, 0x618, 0x0000003F)
    TEGRA_REGDEF_TABLE_RESET(MC_AUD_PTSA_MAX_0, 0x550, 0x0000003F)
    TEGRA_REGDEF_TABLE_RESET(MC_GK2_PTSA_RATE_0, 0x610, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_ISP_PTSA_MAX_0, 0x4A8, 0x0000003F)
    TEGRA_REGDEF_TABLE_RESET(MC_DISB_PTSA_RATE_0, 0x428, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_VE2_PTSA_MAX_0, 0x49C, 0x0000003F)
    TEGRA_REGDEF_TABLE_RESET(MC_DFD_PTSA_MIN_0, 0x638, 0x0000003F)
    TEGRA_REGDEF_TABLE_RESET(MC_FTOP_PTSA_RATE_0, 0x50C, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_A9AVPPC_PTSA_RATE_0, 0x488, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_VE2_PTSA_MIN_0, 0x498, 0x0000003F)
    TEGRA_REGDEF_TABLE_RESET(MC_USBX_PTSA_MAX_0, 0x52C, 0x0000003F)
    TEGRA_REGDEF_TABLE_RESET(MC_DIS_PTSA_RATE_0, 0x41C, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_USBD_PTSA_MAX_0, 0x538, 0x0000003F)
    TEGRA_REGDEF_TABLE_RESET(MC_A9AVPPC_PTSA_MAX_0, 0x490, 0x0000003F)
    TEGRA_REGDEF_TABLE_RESET(MC_USBX_PTSA_RATE_0, 0x524, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_FTOP_PTSA_MAX_0, 0x514, 0x0000003F)
    TEGRA_REGDEF_TABLE_RESET(MC_HDAPC_PTSA_MAX_0, 0x630, 0x0000003F)
    TEGRA_REGDEF_TABLE_RESET(MC_SD_PTSA_RATE_0, 0x4D0, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_DFD_PTSA_RATE_0, 0x634, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_FTOP_PTSA_MIN_0, 0x510, 0x0000003F)
    TEGRA_REGDEF_TABLE_RESET(MC_SDM_PTSA_RATE_0, 0x61C, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_AHB_PTSA_RATE_0, 0x4DC, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_SMMU_SMMU_PTSA_MAX_0, 0x460, 0x0000003F)
    TEGRA_REGDEF_TABLE_RESET(MC_RING2_PTSA_MIN_0, 0x444, 0x0000003F)
    TEGRA_REGDEF_TABLE_RESET(MC_SDM_PTSA_MIN_0, 0x620, 0x0000003F)
    TEGRA_REGDEF_TABLE_RESET(MC_APB_PTSA_RATE_0, 0x4E8, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_MSE_PTSA_MIN_0, 0x4C8, 0x0000003F)
    TEGRA_REGDEF_TABLE_RESET(MC_HOST_PTSA_RATE_0, 0x518, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_VE_PTSA_RATE_0, 0x434, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_AHB_PTSA_MAX_0, 0x4E4, 0x0000003F)
    TEGRA_REGDEF_TABLE_RESET(MC_SAX_PTSA_MIN_0, 0x4BC, 0x0000003F)
    TEGRA_REGDEF_TABLE_RESET(MC_SMMU_SMMU_PTSA_MIN_0, 0x45C, 0x0000003F)
    TEGRA_REGDEF_TABLE_RESET(MC_ISP_PTSA_MIN_0, 0x4A4, 0x0000003F)
    TEGRA_REGDEF_TABLE_RESET(MC_HOST_PTSA_MAX_0, 0x520, 0x0000003F)
    TEGRA_REGDEF_TABLE_RESET(MC_SAX_PTSA_MAX_0, 0x4C0, 0x0000003F)
    TEGRA_REGDEF_TABLE_RESET(MC_VE_PTSA_MIN_0, 0x438, 0x0000003F)
    TEGRA_REGDEF_TABLE_RESET(MC_GK_PTSA_MIN_0, 0x540, 0x0000003F)
    TEGRA_REGDEF_TABLE_RESET(MC_MSE_PTSA_MAX_0, 0x4CC, 0x0000003F)
    TEGRA_REGDEF_TABLE_RESET(MC_DISB_PTSA_MAX_0, 0x430, 0x0000003F)
    TEGRA_REGDEF_TABLE_RESET(MC_DISB_PTSA_MIN_0, 0x42C, 0x0000003F)
    TEGRA_REGDEF_TABLE_RESET(MC_SMMU_SMMU_PTSA_RATE_0, 0x458, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_VE2_PTSA_RATE_0, 0x494, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_GK_PTSA_RATE_0, 0x53C, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_PTSA_GRANT_DECREMENT_0, 0x960, 0x00001000)
    TEGRA_REGDEF_TABLE_RESET(MC_LATENCY_ALLOWANCE_AVPC_0_0, 0x2E4, 0x00800004)
    TEGRA_REGDEF_TABLE_RESET(MC_LATENCY_ALLOWANCE_AXIAP_0_0, 0x3A0, 0x008000FF)
    TEGRA_REGDEF_TABLE_RESET(MC_LATENCY_ALLOWANCE_XUSB_1_0, 0x380, 0x00800039)
    TEGRA_REGDEF_TABLE_RESET(MC_LATENCY_ALLOWANCE_ISP2B_0_0, 0x384, 0x00000018)
    TEGRA_REGDEF_TABLE_RESET(MC_LATENCY_ALLOWANCE_SDMMCAA_0_0, 0x3BC, 0x0080005A)
    TEGRA_REGDEF_TABLE_RESET(MC_LATENCY_ALLOWANCE_SDMMCA_0_0, 0x3B8, 0x00800049)
    TEGRA_REGDEF_TABLE_RESET(MC_LATENCY_ALLOWANCE_ISP2_0_0, 0x370, 0x00000018)
    TEGRA_REGDEF_TABLE_RESET(MC_LATENCY_ALLOWANCE_SE_0_0, 0x3E0, 0x0080002E)
    TEGRA_REGDEF_TABLE_RESET(MC_LATENCY_ALLOWANCE_ISP2_1_0, 0x374, 0x00800080)
    TEGRA_REGDEF_TABLE_RESET(MC_LATENCY_ALLOWANCE_DC_0_0, 0x2E8, 0x001E001E)
    TEGRA_REGDEF_TABLE_RESET(MC_LATENCY_ALLOWANCE_VIC_0_0, 0x394, 0x0080001A)
    TEGRA_REGDEF_TABLE_RESET(MC_LATENCY_ALLOWANCE_DCB_1_0, 0x2F8, 0x0000001E)
    TEGRA_REGDEF_TABLE_RESET(MC_LATENCY_ALLOWANCE_NVDEC_0_0, 0x3D8, 0x00800023)
    TEGRA_REGDEF_TABLE_RESET(MC_LATENCY_ALLOWANCE_DCB_2_0, 0x2FC, 0x0000001E)
    TEGRA_REGDEF_TABLE_RESET(MC_LATENCY_ALLOWANCE_TSEC_0_0, 0x390, 0x0080009B)
    TEGRA_REGDEF_TABLE_RESET(MC_LATENCY_ALLOWANCE_DC_2_0, 0x2F0, 0x001E001E)
    TEGRA_REGDEF_TABLE_RESET(MC_SCALED_LATENCY_ALLOWANCE_DISPLAY0AB_0, 0x694, 0x001E001E)
    TEGRA_REGDEF_TABLE_RESET(MC_LATENCY_ALLOWANCE_PPCS_1_0, 0x348, 0x00800080)
    TEGRA_REGDEF_TABLE_RESET(MC_LATENCY_ALLOWANCE_XUSB_0_0, 0x37C, 0x0080007A)
    TEGRA_REGDEF_TABLE_RESET(MC_LATENCY_ALLOWANCE_PPCS_0_0, 0x344, 0x001A0049)
    TEGRA_REGDEF_TABLE_RESET(MC_LATENCY_ALLOWANCE_TSECB_0_0, 0x3F0, 0x0080009B)
    TEGRA_REGDEF_TABLE_RESET(MC_LATENCY_ALLOWANCE_AFI_0_0, 0x2E0, 0x0080002E)
    TEGRA_REGDEF_TABLE_RESET(MC_SCALED_LATENCY_ALLOWANCE_DISPLAY0B_0, 0x698, 0x001E001E)
    TEGRA_REGDEF_TABLE_RESET(MC_LATENCY_ALLOWANCE_DC_1_0, 0x2EC, 0x0000001E)
    TEGRA_REGDEF_TABLE_RESET(MC_LATENCY_ALLOWANCE_APE_0_0, 0x3DC, 0x008000FF)
    TEGRA_REGDEF_TABLE_RESET(MC_SCALED_LATENCY_ALLOWANCE_DISPLAY0C_0, 0x6A0, 0x001E001E)
    TEGRA_REGDEF_TABLE_RESET(MC_LATENCY_ALLOWANCE_A9AVP_0_0, 0x3A4, 0x00800004)
    TEGRA_REGDEF_TABLE_RESET(MC_LATENCY_ALLOWANCE_GPU2_0_0, 0x3E8, 0x0080001A)
    TEGRA_REGDEF_TABLE_RESET(MC_LATENCY_ALLOWANCE_DCB_0_0, 0x2F4, 0x001E001E)
    TEGRA_REGDEF_TABLE_RESET(MC_LATENCY_ALLOWANCE_HC_1_0, 0x314, 0x00000080)
    TEGRA_REGDEF_TABLE_RESET(MC_LATENCY_ALLOWANCE_SDMMC_0_0, 0x3C0, 0x00800049)
    TEGRA_REGDEF_TABLE_RESET(MC_LATENCY_ALLOWANCE_NVJPG_0_0, 0x3E4, 0x00800023)
    TEGRA_REGDEF_TABLE_RESET(MC_LATENCY_ALLOWANCE_PTC_0_0, 0x34C, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(MC_LATENCY_ALLOWANCE_ETR_0_0, 0x3EC, 0x008000FF)
    TEGRA_REGDEF_TABLE_RESET(MC_LATENCY_ALLOWANCE_MPCORE_0_0, 0x320, 0x00800004)
    TEGRA_REGDEF_TABLE_RESET(MC_LATENCY_ALLOWANCE_VI2_0_0, 0x398, 0x00000080)
    TEGRA_REGDEF_TABLE_RESET(MC_SCALED_LATENCY_ALLOWANCE_DISPLAY0BB_0, 0x69C, 0x001E001E)
    TEGRA_REGDEF_TABLE_RESET(MC_SCALED_LATENCY_ALLOWANCE_DISPLAY0CB_0, 0x6A4, 0x001E001E)
    TEGRA_REGDEF_TABLE_RESET(MC_LATENCY_ALLOWANCE_SATA_0_0, 0x350, 0x00800065)
    TEGRA_REGDEF_TABLE_RESET(MC_SCALED_LATENCY_ALLOWANCE_DISPLAY0A_0, 0x690, 0x001E001E)
    TEGRA_REGDEF_TABLE_RESET(MC_LATENCY_ALLOWANCE_HC_0_0, 0x310, 0x0050001E)
    TEGRA_REGDEF_TABLE_RESET(MC_LATENCY_ALLOWANCE_DC_3_0, 0x3C8, 0x0000001E)
    TEGRA_REGDEF_TABLE_RESET(MC_LATENCY_ALLOWANCE_GPU_0_0, 0x3AC, 0x0080001A)
    TEGRA_REGDEF_TABLE_RESET(MC_LATENCY_ALLOWANCE_SDMMCAB_0_0, 0x3C4, 0x0080005A)
    TEGRA_REGDEF_TABLE_RESET(MC_LATENCY_ALLOWANCE_ISP2B_1_0, 0x388, 0x00800080)
    TEGRA_REGDEF_TABLE_RESET(MC_LATENCY_ALLOWANCE_NVENC_0_0, 0x328, 0x00800023)
    TEGRA_REGDEF_TABLE_RESET(MC_LATENCY_ALLOWANCE_HDA_0_0, 0x318, 0x00800024)
};

static uint64_t tegra_mc_priv_read(void *opaque, hwaddr offset,
                                   unsigned size)
{
    tegra_mc *s = opaque;
    uint64_t ret = 0;

    switch (offset) {
    case ERR_STATUS_OFFSET:
        ret = s->err_status.reg32;
        break;
    case EMEM_ARB_CFG0_OFFSET:
        ret = s->emem_arb_cfg0.reg32;
        break;
    case EMEM_ARB_CFG1_OFFSET:
        ret = s->emem_arb_cfg1.reg32;
        break;
    case EMEM_ARB_CFG2_OFFSET:
        ret = s->emem_arb_cfg2.reg32;
        break;
    case GART_CONFIG_OFFSET:
        ret = s->gart_config.reg32;
        break;
    case GART_ENTRY_ADDR_OFFSET:
        ret = s->gart_entry_addr.reg32;
        break;
    case GART_ENTRY_DATA_OFFSET:
        ret = s->gart_entry_data.reg32;
        break;
    case GART_ERROR_REQ_OFFSET:
        ret = s->gart_error_req.reg32;
        break;
    case GART_ERROR_ADDR_OFFSET:
        ret = s->gart_error_addr.reg32;
        break;
    case TIMEOUT_CTRL_OFFSET:
        ret = s->timeout_ctrl.reg32;
        break;
    case DECERR_EMEM_OTHERS_STATUS_OFFSET:
        ret = s->decerr_emem_others_status.reg32;
        break;
    case DECERR_EMEM_OTHERS_ADR_OFFSET:
        ret = s->decerr_emem_others_adr.reg32;
        break;
    case CLIENT_CTRL_OFFSET:
        ret = s->client_ctrl.reg32;
        break;
    case CLIENT_HOTRESETN_OFFSET:
        ret = s->client_hotresetn.reg32;
        break;
    case LOWLATENCY_RAWLOGIC_WRITE_PARTICIPANTS_OFFSET:
        ret = s->lowlatency_rawlogic_write_participants.reg32;
        break;
    case BWSHARE_TMVAL_OFFSET:
        ret = s->bwshare_tmval.reg32;
        break;
    case BWSHARE_EMEM_CTRL_0_OFFSET:
        ret = s->bwshare_emem_ctrl_0.reg32;
        break;
    case BWSHARE_EMEM_CTRL_1_OFFSET:
        ret = s->bwshare_emem_ctrl_1.reg32;
        break;
    case AVPC_ORRC_OFFSET:
        ret = s->avpc_orrc.reg32;
        break;
    case DC_ORRC_OFFSET:
        ret = s->dc_orrc.reg32;
        break;
    case DCB_ORRC_OFFSET:
        ret = s->dcb_orrc.reg32;
        break;
    case EPP_ORRC_OFFSET:
        ret = s->epp_orrc.reg32;
        break;
    case G2_ORRC_OFFSET:
        ret = s->g2_orrc.reg32;
        break;
    case HC_ORRC_OFFSET:
        ret = s->hc_orrc.reg32;
        break;
    case ISP_ORRC_OFFSET:
        ret = s->isp_orrc.reg32;
        break;
    case MPCORE_ORRC_OFFSET:
        ret = s->mpcore_orrc.reg32;
        break;
    case MPEA_ORRC_OFFSET:
        ret = s->mpea_orrc.reg32;
        break;
    case MPEB_ORRC_OFFSET:
        ret = s->mpeb_orrc.reg32;
        break;
    case MPEC_ORRC_OFFSET:
        ret = s->mpec_orrc.reg32;
        break;
    case NV_ORRC_OFFSET:
        ret = s->nv_orrc.reg32;
        break;
    case PPCS_ORRC_OFFSET:
        ret = s->ppcs_orrc.reg32;
        break;
    case VDE_ORRC_OFFSET:
        ret = s->vde_orrc.reg32;
        break;
    case VI_ORRC_OFFSET:
        ret = s->vi_orrc.reg32;
        break;
    case FPRI_CTRL_AVPC_OFFSET:
        ret = s->fpri_ctrl_avpc.reg32;
        break;
    case FPRI_CTRL_DC_OFFSET:
        ret = s->fpri_ctrl_dc.reg32;
        break;
    case FPRI_CTRL_DCB_OFFSET:
        ret = s->fpri_ctrl_dcb.reg32;
        break;
    case FPRI_CTRL_EPP_OFFSET:
        ret = s->fpri_ctrl_epp.reg32;
        break;
    case FPRI_CTRL_G2_OFFSET:
        ret = s->fpri_ctrl_g2.reg32;
        break;
    case FPRI_CTRL_HC_OFFSET:
        ret = s->fpri_ctrl_hc.reg32;
        break;
    case FPRI_CTRL_ISP_OFFSET:
        ret = s->fpri_ctrl_isp.reg32;
        break;
    case FPRI_CTRL_MPCORE_OFFSET:
        ret = s->fpri_ctrl_mpcore.reg32;
        break;
    case FPRI_CTRL_MPEA_OFFSET:
        ret = s->fpri_ctrl_mpea.reg32;
        break;
    case FPRI_CTRL_MPEB_OFFSET:
        ret = s->fpri_ctrl_mpeb.reg32;
        break;
    case FPRI_CTRL_MPEC_OFFSET:
        ret = s->fpri_ctrl_mpec.reg32;
        break;
    case FPRI_CTRL_NV_OFFSET:
        ret = s->fpri_ctrl_nv.reg32;
        break;
    case FPRI_CTRL_PPCS_OFFSET:
        ret = s->fpri_ctrl_ppcs.reg32;
        break;
    case FPRI_CTRL_VDE_OFFSET:
        ret = s->fpri_ctrl_vde.reg32;
        break;
    case FPRI_CTRL_VI_OFFSET:
        ret = s->fpri_ctrl_vi.reg32;
        break;
    case TIMEOUT_AVPC_OFFSET:
        ret = s->timeout_avpc.reg32;
        break;
    case TIMEOUT_DC_OFFSET:
        ret = s->timeout_dc.reg32;
        break;
    case TIMEOUT_DCB_OFFSET:
        ret = s->timeout_dcb.reg32;
        break;
    case TIMEOUT_EPP_OFFSET:
        ret = s->timeout_epp.reg32;
        break;
    case TIMEOUT_G2_OFFSET:
        ret = s->timeout_g2.reg32;
        break;
    case TIMEOUT_HC_OFFSET:
        ret = s->timeout_hc.reg32;
        break;
    case TIMEOUT_ISP_OFFSET:
        ret = s->timeout_isp.reg32;
        break;
    case TIMEOUT_MPCORE_OFFSET:
        ret = s->timeout_mpcore.reg32;
        break;
    case TIMEOUT_MPEA_OFFSET:
        ret = s->timeout_mpea.reg32;
        break;
    case TIMEOUT_MPEB_OFFSET:
        ret = s->timeout_mpeb.reg32;
        break;
    case TIMEOUT_MPEC_OFFSET:
        ret = s->timeout_mpec.reg32;
        break;
    case TIMEOUT_NV_OFFSET:
        ret = s->timeout_nv.reg32;
        break;
    case TIMEOUT_PPCS_OFFSET:
        ret = s->timeout_ppcs.reg32;
        break;
    case TIMEOUT_VDE_OFFSET:
        ret = s->timeout_vde.reg32;
        break;
    case TIMEOUT_VI_OFFSET:
        ret = s->timeout_vi.reg32;
        break;
    case TIMEOUT_RCOAL_AVPC_OFFSET:
        ret = s->timeout_rcoal_avpc.reg32;
        break;
    case TIMEOUT_RCOAL_DC_OFFSET:
        ret = s->timeout_rcoal_dc.reg32;
        break;
    case TIMEOUT1_RCOAL_DC_OFFSET:
        ret = s->timeout1_rcoal_dc.reg32;
        break;
    case TIMEOUT_RCOAL_DCB_OFFSET:
        ret = s->timeout_rcoal_dcb.reg32;
        break;
    case TIMEOUT1_RCOAL_DCB_OFFSET:
        ret = s->timeout1_rcoal_dcb.reg32;
        break;
    case TIMEOUT_RCOAL_EPP_OFFSET:
        ret = s->timeout_rcoal_epp.reg32;
        break;
    case TIMEOUT_RCOAL_G2_OFFSET:
        ret = s->timeout_rcoal_g2.reg32;
        break;
    case TIMEOUT_RCOAL_HC_OFFSET:
        ret = s->timeout_rcoal_hc.reg32;
        break;
    case TIMEOUT_RCOAL_MPCORE_OFFSET:
        ret = s->timeout_rcoal_mpcore.reg32;
        break;
    case TIMEOUT_RCOAL_MPEA_OFFSET:
        ret = s->timeout_rcoal_mpea.reg32;
        break;
    case TIMEOUT_RCOAL_MPEB_OFFSET:
        ret = s->timeout_rcoal_mpeb.reg32;
        break;
    case TIMEOUT_RCOAL_MPEC_OFFSET:
        ret = s->timeout_rcoal_mpec.reg32;
        break;
    case TIMEOUT_RCOAL_NV_OFFSET:
        ret = s->timeout_rcoal_nv.reg32;
        break;
    case TIMEOUT_RCOAL_PPCS_OFFSET:
        ret = s->timeout_rcoal_ppcs.reg32;
        break;
    case TIMEOUT_RCOAL_VDE_OFFSET:
        ret = s->timeout_rcoal_vde.reg32;
        break;
    case TIMEOUT_RCOAL_VI_OFFSET:
        ret = s->timeout_rcoal_vi.reg32;
        break;
    case RCOAL_AUTODISABLE_OFFSET:
        ret = s->rcoal_autodisable.reg32;
        break;
    case BWSHARE_AVPC_OFFSET:
        ret = s->bwshare_avpc.reg32;
        break;
    case BWSHARE_DC_OFFSET:
        ret = s->bwshare_dc.reg32;
        break;
    case BWSHARE_DCB_OFFSET:
        ret = s->bwshare_dcb.reg32;
        break;
    case BWSHARE_EPP_OFFSET:
        ret = s->bwshare_epp.reg32;
        break;
    case BWSHARE_G2_OFFSET:
        ret = s->bwshare_g2.reg32;
        break;
    case BWSHARE_HC_OFFSET:
        ret = s->bwshare_hc.reg32;
        break;
    case BWSHARE_ISP_OFFSET:
        ret = s->bwshare_isp.reg32;
        break;
    case BWSHARE_MPCORE_OFFSET:
        ret = s->bwshare_mpcore.reg32;
        break;
    case BWSHARE_MPEA_OFFSET:
        ret = s->bwshare_mpea.reg32;
        break;
    case BWSHARE_MPEB_OFFSET:
        ret = s->bwshare_mpeb.reg32;
        break;
    case BWSHARE_MPEC_OFFSET:
        ret = s->bwshare_mpec.reg32;
        break;
    case BWSHARE_NV_OFFSET:
        ret = s->bwshare_nv.reg32;
        break;
    case BWSHARE_PPCS_OFFSET:
        ret = s->bwshare_ppcs.reg32;
        break;
    case BWSHARE_VDE_OFFSET:
        ret = s->bwshare_vde.reg32;
        break;
    case BWSHARE_VI_OFFSET:
        ret = s->bwshare_vi.reg32;
        break;
    case INTSTATUS_OFFSET:
        ret = s->intstatus.reg32;
        break;
    case INTMASK_OFFSET:
        ret = s->intmask.reg32;
        break;
    case CLKEN_OVERRIDE_OFFSET:
        ret = s->clken_override.reg32;
        break;
    case SECURITY_CFG0_OFFSET:
        ret = s->security_cfg0.reg32;
        break;
    case SECURITY_CFG1_OFFSET:
        ret = s->security_cfg1.reg32;
        break;
    case SECURITY_VIOLATION_STATUS_OFFSET:
        ret = s->security_violation_status.reg32;
        break;
    case SECURITY_VIOLATION_ADR_OFFSET:
        ret = s->security_violation_adr.reg32;
        break;
    case SECURITY_CFG2_OFFSET:
        ret = s->security_cfg2.reg32;
        break;
    case STAT_CONTROL_OFFSET:
        ret = s->stat_control.reg32;
        break;
    case STAT_STATUS_OFFSET:
        ret = s->stat_status.reg32;
        break;
    case STAT_EMC_ADDR_LOW_OFFSET:
        ret = s->stat_emc_addr_low.reg32;
        break;
    case STAT_EMC_ADDR_HIGH_OFFSET:
        ret = s->stat_emc_addr_high.reg32;
        break;
    case STAT_EMC_CLOCK_LIMIT_OFFSET:
        ret = s->stat_emc_clock_limit.reg32;
        break;
    case STAT_EMC_CLOCKS_OFFSET:
        ret = s->stat_emc_clocks.reg32;
        break;
    case STAT_EMC_CONTROL_0_OFFSET:
        ret = s->stat_emc_control_0.reg32;
        break;
    case STAT_EMC_CONTROL_1_OFFSET:
        ret = s->stat_emc_control_1.reg32;
        break;
    case STAT_EMC_HIST_LIMIT_0_OFFSET:
        ret = s->stat_emc_hist_limit_0.reg32;
        break;
    case STAT_EMC_HIST_LIMIT_1_OFFSET:
        ret = s->stat_emc_hist_limit_1.reg32;
        break;
    case STAT_EMC_COUNT_0_OFFSET:
        ret = s->stat_emc_count_0.reg32;
        break;
    case STAT_EMC_COUNT_1_OFFSET:
        ret = s->stat_emc_count_1.reg32;
        break;
    case STAT_EMC_HIST_0_OFFSET:
        ret = s->stat_emc_hist_0.reg32;
        break;
    case STAT_EMC_HIST_1_OFFSET:
        ret = s->stat_emc_hist_1.reg32;
        break;
    case AXI_DECERR_OVR_OFFSET:
        ret = s->axi_decerr_ovr.reg32;
        break;
    case LOWLATENCY_CONFIG_OFFSET:
        ret = s->lowlatency_config.reg32;
        break;
    case AP_CTRL_0_OFFSET:
        ret = s->ap_ctrl_0.reg32;
        break;
    case AP_CTRL_1_OFFSET:
        ret = s->ap_ctrl_1.reg32;
        break;
    case CLIENT_ACTIVITY_MONITOR_EMEM_0_OFFSET:
        ret = s->client_activity_monitor_emem_0.reg32;
        break;
    case CLIENT_ACTIVITY_MONITOR_EMEM_1_OFFSET:
        ret = s->client_activity_monitor_emem_1.reg32;
        break;
    default:
        if (offset == s->emem_cfg_offset) ret = s->emem_cfg.reg32;
        else if (offset == s->emem_adr_cfg_offset) ret = s->emem_adr_cfg.reg32;
        else if (tegra_board >= TEGRAX1_BOARD && offset == SMMU_CONFIG_OFFSET) ret = s->smmu_config.reg32;
        else if (tegra_board >= TEGRAX1_BOARD && offset <= sizeof(s->regs)-4)
            ret = s->regs[offset>>2];
        break;
    }

    TRACE_READ(s->iomem.addr, offset, ret);

    return ret;
}

static void tegra_mc_priv_write(void *opaque, hwaddr offset,
                                uint64_t value, unsigned size)
{
    tegra_mc *s = opaque;

    switch (offset) {
    case ERR_STATUS_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->err_status.reg32, value);
        s->err_status.reg32 = value;
        break;
    case EMEM_ARB_CFG0_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->emem_arb_cfg0.reg32, value);
        s->emem_arb_cfg0.reg32 = value;
        break;
    case EMEM_ARB_CFG1_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->emem_arb_cfg1.reg32, value);
        s->emem_arb_cfg1.reg32 = value;
        break;
    case EMEM_ARB_CFG2_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->emem_arb_cfg2.reg32, value);
        s->emem_arb_cfg2.reg32 = value;
        break;
    case GART_CONFIG_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->gart_config.reg32, value);
        s->gart_config.reg32 = value;
        break;
    case GART_ENTRY_ADDR_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->gart_entry_addr.reg32, value);
        s->gart_entry_addr.reg32 = value;
        break;
    case GART_ENTRY_DATA_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->gart_entry_data.reg32, value);
        s->gart_entry_data.reg32 = value;
        break;
    case GART_ERROR_REQ_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->gart_error_req.reg32, value);
        if (tegra_board >= TEGRAX1_BOARD) s->gart_error_req.reg32 = value;
        break;
    case GART_ERROR_ADDR_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->gart_error_addr.reg32, value);
        if (tegra_board >= TEGRAX1_BOARD) s->gart_error_addr.reg32 = value;
        break;
    case TIMEOUT_CTRL_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->timeout_ctrl.reg32, value);
        s->timeout_ctrl.reg32 = value;
        break;
    case DECERR_EMEM_OTHERS_STATUS_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->decerr_emem_others_status.reg32, value);
        if (tegra_board >= TEGRAX1_BOARD) s->decerr_emem_others_status.reg32 = value;
        break;
    case DECERR_EMEM_OTHERS_ADR_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->decerr_emem_others_adr.reg32, value);
        if (tegra_board >= TEGRAX1_BOARD) s->decerr_emem_others_adr.reg32 = value;
        break;
    case CLIENT_CTRL_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->client_ctrl.reg32, value);
        s->client_ctrl.reg32 = value;
        break;
    case CLIENT_HOTRESETN_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->client_hotresetn.reg32, value);
        s->client_hotresetn.reg32 = value;
        break;
    case LOWLATENCY_RAWLOGIC_WRITE_PARTICIPANTS_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->lowlatency_rawlogic_write_participants.reg32, value);
        s->lowlatency_rawlogic_write_participants.reg32 = value;
        break;
    case BWSHARE_TMVAL_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->bwshare_tmval.reg32, value);
        s->bwshare_tmval.reg32 = value;
        break;
    case BWSHARE_EMEM_CTRL_0_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->bwshare_emem_ctrl_0.reg32, value);
        s->bwshare_emem_ctrl_0.reg32 = value;
        break;
    case BWSHARE_EMEM_CTRL_1_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->bwshare_emem_ctrl_1.reg32, value);
        s->bwshare_emem_ctrl_1.reg32 = value;
        break;
    case FPRI_CTRL_AVPC_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->fpri_ctrl_avpc.reg32, value);
        s->fpri_ctrl_avpc.reg32 = value;
        break;
    case FPRI_CTRL_DC_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->fpri_ctrl_dc.reg32, value);
        s->fpri_ctrl_dc.reg32 = value;
        break;
    case FPRI_CTRL_DCB_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->fpri_ctrl_dcb.reg32, value);
        s->fpri_ctrl_dcb.reg32 = value;
        break;
    case FPRI_CTRL_EPP_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->fpri_ctrl_epp.reg32, value);
        s->fpri_ctrl_epp.reg32 = value;
        break;
    case FPRI_CTRL_G2_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->fpri_ctrl_g2.reg32, value);
        s->fpri_ctrl_g2.reg32 = value;
        break;
    case FPRI_CTRL_HC_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->fpri_ctrl_hc.reg32, value);
        s->fpri_ctrl_hc.reg32 = value;
        break;
    case FPRI_CTRL_ISP_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->fpri_ctrl_isp.reg32, value);
        s->fpri_ctrl_isp.reg32 = value;
        break;
    case FPRI_CTRL_MPCORE_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->fpri_ctrl_mpcore.reg32, value);
        s->fpri_ctrl_mpcore.reg32 = value;
        break;
    case FPRI_CTRL_MPEA_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->fpri_ctrl_mpea.reg32, value);
        s->fpri_ctrl_mpea.reg32 = value;
        break;
    case FPRI_CTRL_MPEB_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->fpri_ctrl_mpeb.reg32, value);
        s->fpri_ctrl_mpeb.reg32 = value;
        break;
    case FPRI_CTRL_MPEC_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->fpri_ctrl_mpec.reg32, value);
        s->fpri_ctrl_mpec.reg32 = value;
        break;
    case FPRI_CTRL_NV_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->fpri_ctrl_nv.reg32, value);
        s->fpri_ctrl_nv.reg32 = value;
        break;
    case FPRI_CTRL_PPCS_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->fpri_ctrl_ppcs.reg32, value);
        s->fpri_ctrl_ppcs.reg32 = value;
        break;
    case FPRI_CTRL_VDE_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->fpri_ctrl_vde.reg32, value);
        s->fpri_ctrl_vde.reg32 = value;
        break;
    case FPRI_CTRL_VI_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->fpri_ctrl_vi.reg32, value);
        s->fpri_ctrl_vi.reg32 = value;
        break;
    case TIMEOUT_AVPC_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->timeout_avpc.reg32, value);
        s->timeout_avpc.reg32 = value;
        break;
    case TIMEOUT_DC_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->timeout_dc.reg32, value);
        s->timeout_dc.reg32 = value;
        break;
    case TIMEOUT_DCB_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->timeout_dcb.reg32, value);
        s->timeout_dcb.reg32 = value;
        break;
    case TIMEOUT_EPP_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->timeout_epp.reg32, value);
        s->timeout_epp.reg32 = value;
        break;
    case TIMEOUT_G2_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->timeout_g2.reg32, value);
        s->timeout_g2.reg32 = value;
        break;
    case TIMEOUT_HC_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->timeout_hc.reg32, value);
        s->timeout_hc.reg32 = value;
        break;
    case TIMEOUT_ISP_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->timeout_isp.reg32, value);
        s->timeout_isp.reg32 = value;
        break;
    case TIMEOUT_MPCORE_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->timeout_mpcore.reg32, value);
        s->timeout_mpcore.reg32 = value;
        break;
    case TIMEOUT_MPEA_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->timeout_mpea.reg32, value);
        s->timeout_mpea.reg32 = value;
        break;
    case TIMEOUT_MPEB_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->timeout_mpeb.reg32, value);
        s->timeout_mpeb.reg32 = value;
        break;
    case TIMEOUT_MPEC_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->timeout_mpec.reg32, value);
        s->timeout_mpec.reg32 = value;
        break;
    case TIMEOUT_NV_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->timeout_nv.reg32, value);
        s->timeout_nv.reg32 = value;
        break;
    case TIMEOUT_PPCS_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->timeout_ppcs.reg32, value);
        s->timeout_ppcs.reg32 = value;
        break;
    case TIMEOUT_VDE_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->timeout_vde.reg32, value);
        s->timeout_vde.reg32 = value;
        break;
    case TIMEOUT_VI_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->timeout_vi.reg32, value);
        s->timeout_vi.reg32 = value;
        break;
    case TIMEOUT_RCOAL_AVPC_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->timeout_rcoal_avpc.reg32, value);
        s->timeout_rcoal_avpc.reg32 = value;
        break;
    case TIMEOUT_RCOAL_DC_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->timeout_rcoal_dc.reg32, value);
        s->timeout_rcoal_dc.reg32 = value;
        break;
    case TIMEOUT1_RCOAL_DC_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->timeout1_rcoal_dc.reg32, value);
        s->timeout1_rcoal_dc.reg32 = value;
        break;
    case TIMEOUT_RCOAL_DCB_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->timeout_rcoal_dcb.reg32, value);
        s->timeout_rcoal_dcb.reg32 = value;
        break;
    case TIMEOUT1_RCOAL_DCB_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->timeout1_rcoal_dcb.reg32, value);
        s->timeout1_rcoal_dcb.reg32 = value;
        break;
    case TIMEOUT_RCOAL_EPP_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->timeout_rcoal_epp.reg32, value);
        s->timeout_rcoal_epp.reg32 = value;
        break;
    case TIMEOUT_RCOAL_G2_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->timeout_rcoal_g2.reg32, value);
        s->timeout_rcoal_g2.reg32 = value;
        break;
    case TIMEOUT_RCOAL_HC_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->timeout_rcoal_hc.reg32, value);
        s->timeout_rcoal_hc.reg32 = value;
        break;
    case TIMEOUT_RCOAL_MPCORE_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->timeout_rcoal_mpcore.reg32, value);
        s->timeout_rcoal_mpcore.reg32 = value;
        break;
    case TIMEOUT_RCOAL_MPEA_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->timeout_rcoal_mpea.reg32, value);
        s->timeout_rcoal_mpea.reg32 = value;
        break;
    case TIMEOUT_RCOAL_MPEB_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->timeout_rcoal_mpeb.reg32, value);
        s->timeout_rcoal_mpeb.reg32 = value;
        break;
    case TIMEOUT_RCOAL_MPEC_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->timeout_rcoal_mpec.reg32, value);
        s->timeout_rcoal_mpec.reg32 = value;
        break;
    case TIMEOUT_RCOAL_NV_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->timeout_rcoal_nv.reg32, value);
        s->timeout_rcoal_nv.reg32 = value;
        break;
    case TIMEOUT_RCOAL_PPCS_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->timeout_rcoal_ppcs.reg32, value);
        s->timeout_rcoal_ppcs.reg32 = value;
        break;
    case TIMEOUT_RCOAL_VDE_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->timeout_rcoal_vde.reg32, value);
        s->timeout_rcoal_vde.reg32 = value;
        break;
    case TIMEOUT_RCOAL_VI_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->timeout_rcoal_vi.reg32, value);
        s->timeout_rcoal_vi.reg32 = value;
        break;
    case RCOAL_AUTODISABLE_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->rcoal_autodisable.reg32, value);
        s->rcoal_autodisable.reg32 = value;
        break;
    case BWSHARE_AVPC_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->bwshare_avpc.reg32, value);
        s->bwshare_avpc.reg32 = value;
        break;
    case BWSHARE_DC_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->bwshare_dc.reg32, value);
        s->bwshare_dc.reg32 = value;
        break;
    case BWSHARE_DCB_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->bwshare_dcb.reg32, value);
        s->bwshare_dcb.reg32 = value;
        break;
    case BWSHARE_EPP_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->bwshare_epp.reg32, value);
        s->bwshare_epp.reg32 = value;
        break;
    case BWSHARE_G2_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->bwshare_g2.reg32, value);
        s->bwshare_g2.reg32 = value;
        break;
    case BWSHARE_HC_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->bwshare_hc.reg32, value);
        s->bwshare_hc.reg32 = value;
        break;
    case BWSHARE_ISP_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->bwshare_isp.reg32, value);
        s->bwshare_isp.reg32 = value;
        break;
    case BWSHARE_MPCORE_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->bwshare_mpcore.reg32, value);
        s->bwshare_mpcore.reg32 = value;
        break;
    case BWSHARE_MPEA_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->bwshare_mpea.reg32, value);
        s->bwshare_mpea.reg32 = value;
        break;
    case BWSHARE_MPEB_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->bwshare_mpeb.reg32, value);
        s->bwshare_mpeb.reg32 = value;
        break;
    case BWSHARE_MPEC_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->bwshare_mpec.reg32, value);
        s->bwshare_mpec.reg32 = value;
        break;
    case BWSHARE_NV_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->bwshare_nv.reg32, value);
        s->bwshare_nv.reg32 = value;
        break;
    case BWSHARE_PPCS_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->bwshare_ppcs.reg32, value);
        s->bwshare_ppcs.reg32 = value;
        break;
    case BWSHARE_VDE_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->bwshare_vde.reg32, value);
        s->bwshare_vde.reg32 = value;
        break;
    case BWSHARE_VI_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->bwshare_vi.reg32, value);
        s->bwshare_vi.reg32 = value;
        break;
    case INTSTATUS_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->intstatus.reg32, value);
        s->intstatus.reg32 = value;
        break;
    case INTMASK_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->intmask.reg32, value);
        s->intmask.reg32 = value;
        break;
    case CLKEN_OVERRIDE_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->clken_override.reg32, value);
        s->clken_override.reg32 = value;
        break;
    case SECURITY_CFG0_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->security_cfg0.reg32, value);
        s->security_cfg0.reg32 = value;
        break;
    case SECURITY_CFG1_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->security_cfg1.reg32, value);
        s->security_cfg1.reg32 = value;
        break;
    case SECURITY_VIOLATION_STATUS_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->security_violation_status.reg32, value & SECURITY_VIOLATION_STATUS_WRMASK);
        WR_MASKED(s->security_violation_status.reg32, value, SECURITY_VIOLATION_STATUS);
        break;
    case SECURITY_VIOLATION_ADR_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->security_violation_adr.reg32, value);
        if (tegra_board >= TEGRAX1_BOARD) s->security_violation_adr.reg32 = value;
        break;
    case SECURITY_CFG2_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->security_cfg2.reg32, value);
        s->security_cfg2.reg32 = value;
        break;
    case STAT_CONTROL_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->stat_control.reg32, value);
        s->stat_control.reg32 = value;
        break;
    case STAT_STATUS_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->stat_status.reg32, value & STAT_STATUS_WRMASK);
        WR_MASKED(s->stat_status.reg32, value, STAT_STATUS);
        break;
    case STAT_EMC_ADDR_LOW_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->stat_emc_addr_low.reg32, value);
        s->stat_emc_addr_low.reg32 = value;
        break;
    case STAT_EMC_ADDR_HIGH_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->stat_emc_addr_high.reg32, value);
        s->stat_emc_addr_high.reg32 = value;
        break;
    case STAT_EMC_CLOCK_LIMIT_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->stat_emc_clock_limit.reg32, value);
        s->stat_emc_clock_limit.reg32 = value;
        break;
    case STAT_EMC_CLOCKS_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->stat_emc_clocks.reg32, value);
        if (tegra_board >= TEGRAX1_BOARD) s->stat_emc_clocks.reg32 = value;
        break;
    case STAT_EMC_CONTROL_0_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->stat_emc_control_0.reg32, value);
        s->stat_emc_control_0.reg32 = value;
        break;
    case STAT_EMC_CONTROL_1_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->stat_emc_control_1.reg32, value);
        s->stat_emc_control_1.reg32 = value;
        break;
    case STAT_EMC_HIST_LIMIT_0_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->stat_emc_hist_limit_0.reg32, value);
        s->stat_emc_hist_limit_0.reg32 = value;
        break;
    case STAT_EMC_HIST_LIMIT_1_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->stat_emc_hist_limit_1.reg32, value);
        s->stat_emc_hist_limit_1.reg32 = value;
        break;
    case STAT_EMC_COUNT_0_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->stat_emc_count_0.reg32, value);
        if (tegra_board >= TEGRAX1_BOARD) s->stat_emc_count_0.reg32 = value;
        break;
    case STAT_EMC_COUNT_1_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->stat_emc_count_1.reg32, value);
        if (tegra_board >= TEGRAX1_BOARD) s->stat_emc_count_1.reg32 = value;
        break;
    case STAT_EMC_HIST_0_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->stat_emc_hist_0.reg32, value);
        if (tegra_board >= TEGRAX1_BOARD) s->stat_emc_hist_0.reg32 = value;
        break;
    case STAT_EMC_HIST_1_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->stat_emc_hist_1.reg32, value);
        if (tegra_board >= TEGRAX1_BOARD) s->stat_emc_hist_1.reg32 = value;
        break;
    case AXI_DECERR_OVR_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->axi_decerr_ovr.reg32, value);
        s->axi_decerr_ovr.reg32 = value;
        break;
    case LOWLATENCY_CONFIG_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->lowlatency_config.reg32, value);
        s->lowlatency_config.reg32 = value;
        break;
    case AP_CTRL_0_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->ap_ctrl_0.reg32, value);
        s->ap_ctrl_0.reg32 = value;
        break;
    case AP_CTRL_1_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->ap_ctrl_1.reg32, value);
        s->ap_ctrl_1.reg32 = value;
        break;
    case CLIENT_ACTIVITY_MONITOR_EMEM_0_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->client_activity_monitor_emem_0.reg32, value);
        s->client_activity_monitor_emem_0.reg32 = value;
        break;
    case CLIENT_ACTIVITY_MONITOR_EMEM_1_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->client_activity_monitor_emem_1.reg32, value);
        s->client_activity_monitor_emem_1.reg32 = value;
        break;
    default:
        if (offset == s->emem_cfg_offset) {
            TRACE_WRITE(s->iomem.addr, offset, s->emem_cfg.reg32, value);
            s->emem_cfg.reg32 = value;
        }
        else if (offset == s->emem_adr_cfg_offset) {
            TRACE_WRITE(s->iomem.addr, offset, s->emem_adr_cfg.reg32, value);
            s->emem_adr_cfg.reg32 = value;
        }
        else if (tegra_board >= TEGRAX1_BOARD && offset == SMMU_CONFIG_OFFSET) {
            TRACE_WRITE(s->iomem.addr, offset, s->smmu_config.reg32, value);
            s->smmu_config.reg32 = value;
        }
        else {
            if (tegra_board >= TEGRAX1_BOARD && offset <= sizeof(s->regs)-4) {
                TRACE_WRITE(s->iomem.addr, offset, s->regs[offset>>2], value);
                s->regs[offset>>2] = value;

                tegra_mc *mc_chan = tegra_mc0_dev;
                mc_chan->regs[offset>>2] = value;
                mc_chan = tegra_mc1_dev;
                mc_chan->regs[offset>>2] = value;
            }
            else
                TRACE_WRITE(s->iomem.addr, offset, 0, value);
        }
        break;
    }
}

static void tegra_mc_priv_reset(DeviceState *dev)
{
    tegra_mc *s = TEGRA_MC(dev);

    s->err_status.reg32 = ERR_STATUS_RESET;
    s->emem_arb_cfg0.reg32 = EMEM_ARB_CFG0_RESET;
    s->emem_arb_cfg1.reg32 = EMEM_ARB_CFG1_RESET;
    s->emem_arb_cfg2.reg32 = EMEM_ARB_CFG2_RESET;
    s->gart_config.reg32 = GART_CONFIG_RESET;
    s->gart_entry_addr.reg32 = GART_ENTRY_ADDR_RESET;
    s->gart_entry_data.reg32 = GART_ENTRY_DATA_RESET;
    s->gart_error_req.reg32 = GART_ERROR_REQ_RESET;
    s->gart_error_addr.reg32 = GART_ERROR_ADDR_RESET;
    s->timeout_ctrl.reg32 = TIMEOUT_CTRL_RESET;
    s->decerr_emem_others_status.reg32 = DECERR_EMEM_OTHERS_STATUS_RESET;
    s->decerr_emem_others_adr.reg32 = DECERR_EMEM_OTHERS_ADR_RESET;
    s->client_ctrl.reg32 = CLIENT_CTRL_RESET;
    s->client_hotresetn.reg32 = CLIENT_HOTRESETN_RESET;
    s->lowlatency_rawlogic_write_participants.reg32 = LOWLATENCY_RAWLOGIC_WRITE_PARTICIPANTS_RESET;
    s->bwshare_tmval.reg32 = BWSHARE_TMVAL_RESET;
    s->bwshare_emem_ctrl_0.reg32 = BWSHARE_EMEM_CTRL_0_RESET;
    s->bwshare_emem_ctrl_1.reg32 = BWSHARE_EMEM_CTRL_1_RESET;
    s->avpc_orrc.reg32 = AVPC_ORRC_RESET;
    s->dc_orrc.reg32 = DC_ORRC_RESET;
    s->dcb_orrc.reg32 = DCB_ORRC_RESET;
    s->epp_orrc.reg32 = EPP_ORRC_RESET;
    s->g2_orrc.reg32 = G2_ORRC_RESET;
    s->hc_orrc.reg32 = HC_ORRC_RESET;
    s->isp_orrc.reg32 = ISP_ORRC_RESET;
    s->mpcore_orrc.reg32 = MPCORE_ORRC_RESET;
    s->mpea_orrc.reg32 = MPEA_ORRC_RESET;
    s->mpeb_orrc.reg32 = MPEB_ORRC_RESET;
    s->mpec_orrc.reg32 = MPEC_ORRC_RESET;
    s->nv_orrc.reg32 = NV_ORRC_RESET;
    s->ppcs_orrc.reg32 = PPCS_ORRC_RESET;
    s->vde_orrc.reg32 = VDE_ORRC_RESET;
    s->vi_orrc.reg32 = VI_ORRC_RESET;
    s->fpri_ctrl_avpc.reg32 = FPRI_CTRL_AVPC_RESET;
    s->fpri_ctrl_dc.reg32 = FPRI_CTRL_DC_RESET;
    s->fpri_ctrl_dcb.reg32 = FPRI_CTRL_DCB_RESET;
    s->fpri_ctrl_epp.reg32 = FPRI_CTRL_EPP_RESET;
    s->fpri_ctrl_g2.reg32 = FPRI_CTRL_G2_RESET;
    s->fpri_ctrl_hc.reg32 = FPRI_CTRL_HC_RESET;
    s->fpri_ctrl_isp.reg32 = FPRI_CTRL_ISP_RESET;
    s->fpri_ctrl_mpcore.reg32 = FPRI_CTRL_MPCORE_RESET;
    s->fpri_ctrl_mpea.reg32 = FPRI_CTRL_MPEA_RESET;
    s->fpri_ctrl_mpeb.reg32 = FPRI_CTRL_MPEB_RESET;
    s->fpri_ctrl_mpec.reg32 = FPRI_CTRL_MPEC_RESET;
    s->fpri_ctrl_nv.reg32 = FPRI_CTRL_NV_RESET;
    s->fpri_ctrl_ppcs.reg32 = FPRI_CTRL_PPCS_RESET;
    s->fpri_ctrl_vde.reg32 = FPRI_CTRL_VDE_RESET;
    s->fpri_ctrl_vi.reg32 = FPRI_CTRL_VI_RESET;
    s->timeout_avpc.reg32 = TIMEOUT_AVPC_RESET;
    s->timeout_dc.reg32 = TIMEOUT_DC_RESET;
    s->timeout_dcb.reg32 = TIMEOUT_DCB_RESET;
    s->timeout_epp.reg32 = TIMEOUT_EPP_RESET;
    s->timeout_g2.reg32 = TIMEOUT_G2_RESET;
    s->timeout_hc.reg32 = TIMEOUT_HC_RESET;
    s->timeout_isp.reg32 = TIMEOUT_ISP_RESET;
    s->timeout_mpcore.reg32 = TIMEOUT_MPCORE_RESET;
    s->timeout_mpea.reg32 = TIMEOUT_MPEA_RESET;
    s->timeout_mpeb.reg32 = TIMEOUT_MPEB_RESET;
    s->timeout_mpec.reg32 = TIMEOUT_MPEC_RESET;
    s->timeout_nv.reg32 = TIMEOUT_NV_RESET;
    s->timeout_ppcs.reg32 = TIMEOUT_PPCS_RESET;
    s->timeout_vde.reg32 = TIMEOUT_VDE_RESET;
    s->timeout_vi.reg32 = TIMEOUT_VI_RESET;
    s->timeout_rcoal_avpc.reg32 = TIMEOUT_RCOAL_AVPC_RESET;
    s->timeout_rcoal_dc.reg32 = TIMEOUT_RCOAL_DC_RESET;
    s->timeout1_rcoal_dc.reg32 = TIMEOUT1_RCOAL_DC_RESET;
    s->timeout_rcoal_dcb.reg32 = TIMEOUT_RCOAL_DCB_RESET;
    s->timeout1_rcoal_dcb.reg32 = TIMEOUT1_RCOAL_DCB_RESET;
    s->timeout_rcoal_epp.reg32 = TIMEOUT_RCOAL_EPP_RESET;
    s->timeout_rcoal_g2.reg32 = TIMEOUT_RCOAL_G2_RESET;
    s->timeout_rcoal_hc.reg32 = TIMEOUT_RCOAL_HC_RESET;
    s->timeout_rcoal_mpcore.reg32 = TIMEOUT_RCOAL_MPCORE_RESET;
    s->timeout_rcoal_mpea.reg32 = TIMEOUT_RCOAL_MPEA_RESET;
    s->timeout_rcoal_mpeb.reg32 = TIMEOUT_RCOAL_MPEB_RESET;
    s->timeout_rcoal_mpec.reg32 = TIMEOUT_RCOAL_MPEC_RESET;
    s->timeout_rcoal_nv.reg32 = TIMEOUT_RCOAL_NV_RESET;
    s->timeout_rcoal_ppcs.reg32 = TIMEOUT_RCOAL_PPCS_RESET;
    s->timeout_rcoal_vde.reg32 = TIMEOUT_RCOAL_VDE_RESET;
    s->timeout_rcoal_vi.reg32 = TIMEOUT_RCOAL_VI_RESET;
    s->rcoal_autodisable.reg32 = RCOAL_AUTODISABLE_RESET;
    s->bwshare_avpc.reg32 = BWSHARE_AVPC_RESET;
    s->bwshare_dc.reg32 = BWSHARE_DC_RESET;
    s->bwshare_dcb.reg32 = BWSHARE_DCB_RESET;
    s->bwshare_epp.reg32 = BWSHARE_EPP_RESET;
    s->bwshare_g2.reg32 = BWSHARE_G2_RESET;
    s->bwshare_hc.reg32 = BWSHARE_HC_RESET;
    s->bwshare_isp.reg32 = BWSHARE_ISP_RESET;
    s->bwshare_mpcore.reg32 = BWSHARE_MPCORE_RESET;
    s->bwshare_mpea.reg32 = BWSHARE_MPEA_RESET;
    s->bwshare_mpeb.reg32 = BWSHARE_MPEB_RESET;
    s->bwshare_mpec.reg32 = BWSHARE_MPEC_RESET;
    s->bwshare_nv.reg32 = BWSHARE_NV_RESET;
    s->bwshare_ppcs.reg32 = BWSHARE_PPCS_RESET;
    s->bwshare_vde.reg32 = BWSHARE_VDE_RESET;
    s->bwshare_vi.reg32 = BWSHARE_VI_RESET;
    s->intstatus.reg32 = INTSTATUS_RESET;
    s->intmask.reg32 = INTMASK_RESET;
    s->clken_override.reg32 = CLKEN_OVERRIDE_RESET;
    s->security_cfg0.reg32 = SECURITY_CFG0_RESET;
    s->security_cfg1.reg32 = SECURITY_CFG1_RESET;
    s->security_violation_status.reg32 = SECURITY_VIOLATION_STATUS_RESET;
    s->security_violation_adr.reg32 = SECURITY_VIOLATION_ADR_RESET;
    s->security_cfg2.reg32 = SECURITY_CFG2_RESET;
    s->stat_control.reg32 = STAT_CONTROL_RESET;
    s->stat_status.reg32 = STAT_STATUS_RESET;
    s->stat_emc_addr_low.reg32 = STAT_EMC_ADDR_LOW_RESET;
    s->stat_emc_addr_high.reg32 = STAT_EMC_ADDR_HIGH_RESET;
    s->stat_emc_clock_limit.reg32 = STAT_EMC_CLOCK_LIMIT_RESET;
    s->stat_emc_clocks.reg32 = STAT_EMC_CLOCKS_RESET;
    s->stat_emc_control_0.reg32 = STAT_EMC_CONTROL_0_RESET;
    s->stat_emc_control_1.reg32 = STAT_EMC_CONTROL_1_RESET;
    s->stat_emc_hist_limit_0.reg32 = STAT_EMC_HIST_LIMIT_0_RESET;
    s->stat_emc_hist_limit_1.reg32 = STAT_EMC_HIST_LIMIT_1_RESET;
    s->stat_emc_count_0.reg32 = STAT_EMC_COUNT_0_RESET;
    s->stat_emc_count_1.reg32 = STAT_EMC_COUNT_1_RESET;
    s->stat_emc_hist_0.reg32 = STAT_EMC_HIST_0_RESET;
    s->stat_emc_hist_1.reg32 = STAT_EMC_HIST_1_RESET;
    s->axi_decerr_ovr.reg32 = AXI_DECERR_OVR_RESET;
    s->lowlatency_config.reg32 = LOWLATENCY_CONFIG_RESET;
    s->ap_ctrl_0.reg32 = AP_CTRL_0_RESET;
    s->ap_ctrl_1.reg32 = AP_CTRL_1_RESET;
    s->client_activity_monitor_emem_0.reg32 = CLIENT_ACTIVITY_MONITOR_EMEM_0_RESET;
    s->client_activity_monitor_emem_1.reg32 = CLIENT_ACTIVITY_MONITOR_EMEM_1_RESET;

    memset(s->regs, 0, sizeof(s->regs));

    if (tegra_board >= TEGRAX1_BOARD) {
        s->emem_cfg_offset = EMEM_CFG_TEGRAX1_OFFSET;
        s->emem_adr_cfg_offset = EMEM_ADR_CFG_TEGRAX1_OFFSET;

        for (size_t i=0; i<sizeof(tegra_mc_regdef_tegrax1_reset_table)/sizeof(uint32_t); i+=2) {
            uint32_t offset = tegra_mc_regdef_tegrax1_reset_table[i];
            uint32_t value = tegra_mc_regdef_tegrax1_reset_table[i+1];

            tegra_mc_priv_write(s, offset, value, 4);
        }

        // These undocumented TX1 regs are validated by Erista NX_Bootloader with certain versions.
        s->regs[0x44>>2] = 0x20220000;
        s->regs[0x48>>2] = 0x00002800;
        s->regs[0xDD4>>2] = 0x20220000;
        s->regs[0xDD8>>2] = 0x00002800;
        s->axi_decerr_ovr.reg32 = 0xFFFFFFFF;
        s->lowlatency_config.reg32 = 0x0000FFFF;
        s->regs[0x11C>>2] = 0xFFFFFFFF;
        s->mpcore_orrc.reg32 = 0xFFFFFFFF;
        s->regs[0xA20>>2] = s->regs[0xA24>>2] = s->regs[0xA28>>2] = s->regs[0xA2C>>2] = 0x00000300;
        s->fpri_ctrl_mpea.reg32 = 0xFFFFFFF0;
        s->fpri_ctrl_ppcs.reg32 = 0xFFFFFFF0;
        s->bwshare_emem_ctrl_0.reg32 = 0x0000FFFF<<15;
        s->mpea_orrc.reg32 = 0x0000FFFF<<15;
        s->ap_ctrl_0.reg32 = 0xFFFFFFFF;
        s->mpec_orrc.reg32 = 0xFFFFFFFF;
        s->ap_ctrl_1.reg32 = s->nv_orrc.reg32 = 0x3A660880;
        s->regs[0x130>>2] = s->ppcs_orrc.reg32 = 0x07F37CD0;
        s->regs[0x134>>2] = s->vde_orrc.reg32 = 0xCF0C30FF;
        s->regs[0xB88>>2] = s->regs[0xB8C>>2] = 0x000003FF;
        s->timeout_dcb.reg32 = s->timeout_isp.reg32 = 0x30;
        s->timeout_vde.reg32 = 0x80000000;
        s->regs[0x3FC>>2] = 0xF0000000;
        s->regs[0x2A0>>2] = s->regs[0x2A4>>2] = s->regs[0xA18>>2] = s->regs[0xA08>>2] = s->regs[0xA10>>2] = s->regs[0x40C>>2] = s->regs[0xA40>>2] = s->regs[0x414>>2] = 0x00000004;
        s->regs[0x2BC>>2] = s->regs[0xA3C>>2] = s->regs[0xA14>>2] = s->regs[0x2C0>>2] = s->regs[0xA1C>>2] = s->regs[0xA48>>2] = s->regs[0x2A8>>2] = 0x00000004;
        s->regs[0x404>>2] = s->regs[0x2B8>>2] = s->regs[0xA04>>2] = s->regs[0xA4C>>2] = s->regs[0x2D8>>2] = s->regs[0xA00>>2] = s->regs[0x410>>2] = 0x00000004;
        s->regs[0xA44>>2] = 0x00000004;
        s->regs[0x648>>2] = 0xFFF00000;
        s->regs[0x958>>2] = 0xFF00FF00;
        s->regs[0x990>>2] = s->regs[0x994>>2] = 0x003F0004;
        s->regs[0x9A0>>2] = 0xFFF00000;

        //s->emem_cfg.reg32 = s->ram_size_kb / SZ_1K; // BPMP bootloader initializes this, so this should not be touched unless emulation starts post-bootloader.
    }
    else {
        s->emem_cfg_offset = EMEM_CFG_TEGRA2_OFFSET;
        s->emem_cfg.reg32 = s->ram_size_kb;

        s->emem_adr_cfg_offset = EMEM_ADR_CFG_TEGRA2_OFFSET;
        s->emem_adr_cfg.reg32 = EMEM_ADR_CFG_TEGRA2_RESET;
    }
}

static const MemoryRegionOps tegra_mc_mem_ops = {
    .read = tegra_mc_priv_read,
    .write = tegra_mc_priv_write,
    .endianness = DEVICE_NATIVE_ENDIAN,
};

static void tegra_mc_priv_realize(DeviceState *dev, Error **errp)
{
    tegra_mc *s = TEGRA_MC(dev);

    memory_region_init_io(&s->iomem, OBJECT(dev), &tegra_mc_mem_ops, s,
                          "tegra.mc", TEGRA_MC_SIZE);
    sysbus_init_mmio(SYS_BUS_DEVICE(dev), &s->iomem);
}

static Property tegra_mc_properties[] = {
    DEFINE_PROP_UINT32("ram_size_kb", tegra_mc, ram_size_kb, EMEM_CFG_TEGRAX1_RESET*SZ_1K), \
    DEFINE_PROP_END_OF_LIST(),
};

static void tegra_mc_class_init(ObjectClass *klass, void *data)
{
    DeviceClass *dc = DEVICE_CLASS(klass);

    device_class_set_props(dc, tegra_mc_properties);
    dc->realize = tegra_mc_priv_realize;
    dc->vmsd = &vmstate_tegra_mc;
    dc->reset = tegra_mc_priv_reset;
}

static const TypeInfo tegra_mc_info = {
    .name = TYPE_TEGRA_MC,
    .parent = TYPE_SYS_BUS_DEVICE,
    .instance_size = sizeof(tegra_mc),
    .class_init = tegra_mc_class_init,
};

static void tegra_mc_register_types(void)
{
    type_register_static(&tegra_mc_info);
}

type_init(tegra_mc_register_types)
