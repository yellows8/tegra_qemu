/*
 * ARM NVIDIA Tegra2 emulation.
 *
 * Copyright (c) 2014-2015 Dmitry Osipenko <digetx@gmail.com>
 *
 *  This program is free software; you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by the
 *  Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful, but WITHOUT
 *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 *  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
 *  for more details.
 *
 *  You should have received a copy of the GNU General Public License along
 *  with this program; if not, see <http://www.gnu.org/licenses/>.
 */

#include "tegra_common.h"

#include "hw/sysbus.h"
#include "sysemu/runstate.h"
#include "sysemu/sysemu.h"

#include "car.h"
#include "clk_rst.h"
#include "devices.h"
#include "iomap.h"
#include "remote_io.h"
#include "tegra_cpu.h"
#include "tegra_trace.h"

#define TYPE_TEGRA_CAR "tegra.car"
#define TEGRA_CAR(obj) OBJECT_CHECK(tegra_car, (obj), TYPE_TEGRA_CAR)
#define DEFINE_REG32(reg) reg##_t reg
#define WR_MASKED(r, d, m)  r = (r & ~m##_WRMASK) | (d & m##_WRMASK)

#define PLL_LOCKED (1 << 27)

typedef struct tegra_car_state {
    SysBusDevice parent_obj;

    MemoryRegion iomem;
    uint32_t rst_cpu_cmplx_clr_offset;
    DEFINE_REG32(rst_source);
    DEFINE_REG32(rst_devices_l);
    DEFINE_REG32(rst_devices_h);
    DEFINE_REG32(rst_devices_u);
    DEFINE_REG32(clk_out_enb_l);
    DEFINE_REG32(clk_out_enb_h);
    DEFINE_REG32(clk_out_enb_u);
    DEFINE_REG32(cclk_burst_policy);
    DEFINE_REG32(super_cclk_divider);
    DEFINE_REG32(sclk_burst_policy);
    DEFINE_REG32(super_sclk_divider);
    DEFINE_REG32(clk_system_rate);
    DEFINE_REG32(prog_dly_clk);
    DEFINE_REG32(audio_sync_clk_rate);
    DEFINE_REG32(cop_clk_skip_policy);
    DEFINE_REG32(clk_mask_arm);
    DEFINE_REG32(misc_clk_enb);
    DEFINE_REG32(clk_cpu_cmplx);
    DEFINE_REG32(osc_ctrl);
    DEFINE_REG32(pll_lfsr);
    DEFINE_REG32(osc_freq_det);
    DEFINE_REG32(osc_freq_det_status);
    DEFINE_REG32(plle_ss_cntl);
    DEFINE_REG32(plle_misc1);
    DEFINE_REG32(pllc_base);
    DEFINE_REG32(pllc_out);
    DEFINE_REG32(pllc_misc);
    DEFINE_REG32(pllc_misc_1);
    DEFINE_REG32(pllm_base);
    DEFINE_REG32(pllm_out);
    DEFINE_REG32(pllm_misc1);
    DEFINE_REG32(pllm_misc2);
    DEFINE_REG32(pllp_base);
    DEFINE_REG32(pllp_outa);
    DEFINE_REG32(pllp_outb);
    DEFINE_REG32(pllp_misc);
    DEFINE_REG32(plla_base);
    DEFINE_REG32(plla_out);
    DEFINE_REG32(plla_misc1);
    DEFINE_REG32(plla_misc);
    DEFINE_REG32(pllu_base);
    DEFINE_REG32(pllu_outa);
    DEFINE_REG32(pllu_misc1);
    DEFINE_REG32(pllu_misc);
    DEFINE_REG32(plld_base);
    DEFINE_REG32(plld_misc1);
    DEFINE_REG32(plld_misc);
    DEFINE_REG32(pllx_base);
    DEFINE_REG32(pllx_misc);
    DEFINE_REG32(plle_base);
    DEFINE_REG32(plle_misc);
    DEFINE_REG32(plle_ss_cntl1);
    DEFINE_REG32(plle_ss_cntl2);
    DEFINE_REG32(lvl2_clk_gate_ovra);
    DEFINE_REG32(lvl2_clk_gate_ovrb);
    DEFINE_REG32(clk_source_i2s1);
    DEFINE_REG32(clk_source_i2s2);
    DEFINE_REG32(clk_source_spdif_out);
    DEFINE_REG32(clk_source_spdif_in);
    DEFINE_REG32(clk_source_pwm);
    DEFINE_REG32(clk_source_spi1);
    DEFINE_REG32(clk_source_spi22);
    DEFINE_REG32(clk_source_spi3);
    DEFINE_REG32(clk_source_xio);
    DEFINE_REG32(clk_source_i2c1);
    DEFINE_REG32(clk_source_dvc_i2c);
    DEFINE_REG32(clk_source_twc);
    DEFINE_REG32(clk_source_sbc1);
    DEFINE_REG32(clk_source_disp1);
    DEFINE_REG32(clk_source_disp2);
    DEFINE_REG32(clk_source_cve);
    DEFINE_REG32(clk_source_ide);
    DEFINE_REG32(clk_source_vi);
    DEFINE_REG32(clk_source_sdmmc1);
    DEFINE_REG32(clk_source_sdmmc2);
    DEFINE_REG32(clk_source_g3d);
    DEFINE_REG32(clk_source_g2d);
    DEFINE_REG32(clk_source_ndflash);
    DEFINE_REG32(clk_source_sdmmc4);
    DEFINE_REG32(clk_source_vfir);
    DEFINE_REG32(clk_source_epp);
    DEFINE_REG32(clk_source_mpe);
    DEFINE_REG32(clk_source_mipi);
    DEFINE_REG32(clk_source_uart1);
    DEFINE_REG32(clk_source_uart2);
    DEFINE_REG32(clk_source_host1x);
    DEFINE_REG32(clk_source_tvo);
    DEFINE_REG32(clk_source_hdmi);
    DEFINE_REG32(clk_source_tvdac);
    DEFINE_REG32(clk_source_i2c2);
    DEFINE_REG32(clk_source_emc);
    DEFINE_REG32(clk_source_uart3);
    DEFINE_REG32(clk_source_vi_sensor);
    DEFINE_REG32(clk_source_spi4);
    DEFINE_REG32(clk_source_i2c3);
    DEFINE_REG32(clk_source_sdmmc3);
    DEFINE_REG32(clk_source_uart4);
    DEFINE_REG32(clk_source_uart5);
    DEFINE_REG32(clk_source_vde);
    DEFINE_REG32(clk_source_owr);
    DEFINE_REG32(clk_source_nor);
    DEFINE_REG32(clk_source_csite);
    DEFINE_REG32(clk_source_osc);
    DEFINE_REG32(clk_source_la);
    DEFINE_REG32(rst_cpu_cmplx_set);
    DEFINE_REG32(rst_cpu_cmplx_clr);
    DEFINE_REG32(cpu_cmplx_status);
    DEFINE_REG32(utmip_pll_cfg0);
    DEFINE_REG32(rst_controller_pllc4_base);
    DEFINE_REG32(rst_controller_pllmb_base);
    uint32_t regs[0x748>>2];
} tegra_car;

static const VMStateDescription vmstate_tegra_car = {
    .name = "tegra.car",
    .version_id = 1,
    .minimum_version_id = 1,
    .fields = (VMStateField[]) {
        VMSTATE_UINT32(rst_cpu_cmplx_clr_offset, tegra_car),
        VMSTATE_UINT32(rst_source.reg32, tegra_car),
        VMSTATE_UINT32(rst_devices_l.reg32, tegra_car),
        VMSTATE_UINT32(rst_devices_h.reg32, tegra_car),
        VMSTATE_UINT32(rst_devices_u.reg32, tegra_car),
        VMSTATE_UINT32(clk_out_enb_l.reg32, tegra_car),
        VMSTATE_UINT32(clk_out_enb_h.reg32, tegra_car),
        VMSTATE_UINT32(clk_out_enb_u.reg32, tegra_car),
        VMSTATE_UINT32(cclk_burst_policy.reg32, tegra_car),
        VMSTATE_UINT32(super_cclk_divider.reg32, tegra_car),
        VMSTATE_UINT32(sclk_burst_policy.reg32, tegra_car),
        VMSTATE_UINT32(super_sclk_divider.reg32, tegra_car),
        VMSTATE_UINT32(clk_system_rate.reg32, tegra_car),
        VMSTATE_UINT32(prog_dly_clk.reg32, tegra_car),
        VMSTATE_UINT32(audio_sync_clk_rate.reg32, tegra_car),
        VMSTATE_UINT32(cop_clk_skip_policy.reg32, tegra_car),
        VMSTATE_UINT32(clk_mask_arm.reg32, tegra_car),
        VMSTATE_UINT32(misc_clk_enb.reg32, tegra_car),
        VMSTATE_UINT32(clk_cpu_cmplx.reg32, tegra_car),
        VMSTATE_UINT32(osc_ctrl.reg32, tegra_car),
        VMSTATE_UINT32(pll_lfsr.reg32, tegra_car),
        VMSTATE_UINT32(osc_freq_det.reg32, tegra_car),
        VMSTATE_UINT32(osc_freq_det_status.reg32, tegra_car),
        VMSTATE_UINT32(plle_ss_cntl.reg32, tegra_car),
        VMSTATE_UINT32(plle_misc1.reg32, tegra_car),
        VMSTATE_UINT32(pllc_base.reg32, tegra_car),
        VMSTATE_UINT32(pllc_out.reg32, tegra_car),
        VMSTATE_UINT32(pllc_misc.reg32, tegra_car),
        VMSTATE_UINT32(pllc_misc_1.reg32, tegra_car),
        VMSTATE_UINT32(pllm_base.reg32, tegra_car),
        VMSTATE_UINT32(pllm_out.reg32, tegra_car),
        VMSTATE_UINT32(pllm_misc1.reg32, tegra_car),
        VMSTATE_UINT32(pllm_misc2.reg32, tegra_car),
        VMSTATE_UINT32(pllp_base.reg32, tegra_car),
        VMSTATE_UINT32(pllp_outa.reg32, tegra_car),
        VMSTATE_UINT32(pllp_outb.reg32, tegra_car),
        VMSTATE_UINT32(pllp_misc.reg32, tegra_car),
        VMSTATE_UINT32(plla_base.reg32, tegra_car),
        VMSTATE_UINT32(plla_out.reg32, tegra_car),
        VMSTATE_UINT32(plla_misc1.reg32, tegra_car),
        VMSTATE_UINT32(plla_misc.reg32, tegra_car),
        VMSTATE_UINT32(pllu_base.reg32, tegra_car),
        VMSTATE_UINT32(pllu_outa.reg32, tegra_car),
        VMSTATE_UINT32(pllu_misc1.reg32, tegra_car),
        VMSTATE_UINT32(pllu_misc.reg32, tegra_car),
        VMSTATE_UINT32(plld_base.reg32, tegra_car),
        VMSTATE_UINT32(plld_misc1.reg32, tegra_car),
        VMSTATE_UINT32(plld_misc.reg32, tegra_car),
        VMSTATE_UINT32(pllx_base.reg32, tegra_car),
        VMSTATE_UINT32(pllx_misc.reg32, tegra_car),
        VMSTATE_UINT32(plle_base.reg32, tegra_car),
        VMSTATE_UINT32(plle_misc.reg32, tegra_car),
        VMSTATE_UINT32(plle_ss_cntl1.reg32, tegra_car),
        VMSTATE_UINT32(plle_ss_cntl2.reg32, tegra_car),
        VMSTATE_UINT32(lvl2_clk_gate_ovra.reg32, tegra_car),
        VMSTATE_UINT32(lvl2_clk_gate_ovrb.reg32, tegra_car),
        VMSTATE_UINT32(clk_source_i2s1.reg32, tegra_car),
        VMSTATE_UINT32(clk_source_i2s2.reg32, tegra_car),
        VMSTATE_UINT32(clk_source_spdif_out.reg32, tegra_car),
        VMSTATE_UINT32(clk_source_spdif_in.reg32, tegra_car),
        VMSTATE_UINT32(clk_source_pwm.reg32, tegra_car),
        VMSTATE_UINT32(clk_source_spi1.reg32, tegra_car),
        VMSTATE_UINT32(clk_source_spi22.reg32, tegra_car),
        VMSTATE_UINT32(clk_source_spi3.reg32, tegra_car),
        VMSTATE_UINT32(clk_source_xio.reg32, tegra_car),
        VMSTATE_UINT32(clk_source_i2c1.reg32, tegra_car),
        VMSTATE_UINT32(clk_source_dvc_i2c.reg32, tegra_car),
        VMSTATE_UINT32(clk_source_twc.reg32, tegra_car),
        VMSTATE_UINT32(clk_source_sbc1.reg32, tegra_car),
        VMSTATE_UINT32(clk_source_disp1.reg32, tegra_car),
        VMSTATE_UINT32(clk_source_disp2.reg32, tegra_car),
        VMSTATE_UINT32(clk_source_cve.reg32, tegra_car),
        VMSTATE_UINT32(clk_source_ide.reg32, tegra_car),
        VMSTATE_UINT32(clk_source_vi.reg32, tegra_car),
        VMSTATE_UINT32(clk_source_sdmmc1.reg32, tegra_car),
        VMSTATE_UINT32(clk_source_sdmmc2.reg32, tegra_car),
        VMSTATE_UINT32(clk_source_g3d.reg32, tegra_car),
        VMSTATE_UINT32(clk_source_g2d.reg32, tegra_car),
        VMSTATE_UINT32(clk_source_ndflash.reg32, tegra_car),
        VMSTATE_UINT32(clk_source_sdmmc4.reg32, tegra_car),
        VMSTATE_UINT32(clk_source_vfir.reg32, tegra_car),
        VMSTATE_UINT32(clk_source_epp.reg32, tegra_car),
        VMSTATE_UINT32(clk_source_mpe.reg32, tegra_car),
        VMSTATE_UINT32(clk_source_mipi.reg32, tegra_car),
        VMSTATE_UINT32(clk_source_uart1.reg32, tegra_car),
        VMSTATE_UINT32(clk_source_uart2.reg32, tegra_car),
        VMSTATE_UINT32(clk_source_host1x.reg32, tegra_car),
        VMSTATE_UINT32(clk_source_tvo.reg32, tegra_car),
        VMSTATE_UINT32(clk_source_hdmi.reg32, tegra_car),
        VMSTATE_UINT32(clk_source_tvdac.reg32, tegra_car),
        VMSTATE_UINT32(clk_source_i2c2.reg32, tegra_car),
        VMSTATE_UINT32(clk_source_emc.reg32, tegra_car),
        VMSTATE_UINT32(clk_source_uart3.reg32, tegra_car),
        VMSTATE_UINT32(clk_source_vi_sensor.reg32, tegra_car),
        VMSTATE_UINT32(clk_source_spi4.reg32, tegra_car),
        VMSTATE_UINT32(clk_source_i2c3.reg32, tegra_car),
        VMSTATE_UINT32(clk_source_sdmmc3.reg32, tegra_car),
        VMSTATE_UINT32(clk_source_uart4.reg32, tegra_car),
        VMSTATE_UINT32(clk_source_uart5.reg32, tegra_car),
        VMSTATE_UINT32(clk_source_vde.reg32, tegra_car),
        VMSTATE_UINT32(clk_source_owr.reg32, tegra_car),
        VMSTATE_UINT32(clk_source_nor.reg32, tegra_car),
        VMSTATE_UINT32(clk_source_csite.reg32, tegra_car),
        VMSTATE_UINT32(clk_source_osc.reg32, tegra_car),
        VMSTATE_UINT32(rst_cpu_cmplx_set.reg32, tegra_car),
        VMSTATE_UINT32(rst_cpu_cmplx_clr.reg32, tegra_car),
        VMSTATE_UINT32(cpu_cmplx_status.reg32, tegra_car),
        VMSTATE_UINT32(utmip_pll_cfg0.reg32, tegra_car),
        VMSTATE_UINT32(rst_controller_pllc4_base.reg32, tegra_car),
        VMSTATE_UINT32(rst_controller_pllmb_base.reg32, tegra_car),
        VMSTATE_UINT32(clk_source_la.reg32, tegra_car),
        VMSTATE_UINT32_ARRAY(regs, tegra_car, 0x748>>2),
        VMSTATE_END_OF_LIST()
    }
};

static uint32_t tegra_car_regdef_tegrax1_reset_table[] = {
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_RST_SOURCE_0, 0x0, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_RST_DEVICES_L_0, 0x4, 0x1CD3D2C8)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_RST_DEVICES_H_0, 0x8, 0x87D1F326)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_RST_DEVICES_U_0, 0xC, 0x828EC5FA)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_OUT_ENB_L_0, 0x10, 0x80000130)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_OUT_ENB_H_0, 0x14, 0x00000080)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_OUT_ENB_U_0, 0x18, 0x01F00200)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_SUPER_CCLK_DIVIDER_0, 0x24, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_SCLK_BURST_POLICY_0, 0x28, 0x10000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_SUPER_SCLK_DIVIDER_0, 0x2C, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SYSTEM_RATE_0, 0x30, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_MASK_ARM_0, 0x44, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_MISC_CLK_ENB_0, 0x48, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(DUMMY, 0x4C, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_OSC_CTRL_0, 0x50, 0x500003F1)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_OSC_FREQ_DET_0, 0x58, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_OSC_FREQ_DET_STATUS_0, 0x5C, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_PLLE_SS_CNTL_0, 0x68, 0x00005C00)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_PLLE_MISC1_0, 0x6C, 0x00000010)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_PLLC_BASE_0, 0x80, 0x00108002)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_PLLC_OUT_0, 0x84, 0x00000002)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_PLLC_MISC_0, 0x88, 0x40000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_PLLC_MISC_1_0, 0x8C, 0x08000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_PLLM_BASE_0, 0x90, 0x00002A02)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_PLLM_MISC1_0, 0x98, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_PLLM_MISC2_0, 0x9C, 0x00000010)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_PLLP_BASE_0, 0xA0, 0x00115408)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_PLLP_OUTA_0, 0xA4, 0x00000002)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_PLLP_OUTB_0, 0xA8, 0x00020002)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_PLLP_MISC_0, 0xAC, 0x00040000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_PLLA_BASE_0, 0xB0, 0x00803003)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_PLLA_OUT_0, 0xB4, 0x00000002)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_PLLA_MISC1_0, 0xB8, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_PLLA_MISC_0, 0xBC, 0x12000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_PLLU_BASE_0, 0xC0, 0x01011902)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_PLLU_OUTA_0, 0xC4, 0x00020002)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_PLLU_MISC1_0, 0xC8, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_PLLU_MISC_0, 0xCC, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_PLLD_BASE_0, 0xD0, 0x00211001)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_PLLD_MISC1_0, 0xD8, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_PLLD_MISC_0, 0xDC, 0x00040000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_PLLX_BASE_0, 0xE0, 0x00002401)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_PLLX_MISC_0, 0xE4, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_PLLE_BASE_0, 0xE8, 0x0E007D02)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_PLLE_MISC_0, 0xEC, 0x00006200)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_PLLE_SS_CNTL1_0, 0xF0, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_PLLE_SS_CNTL2_0, 0xF4, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_LVL2_CLK_GATE_OVRA_0, 0xF8, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_LVL2_CLK_GATE_OVRB_0, 0xFC, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_LVL2_CLK_GATE_OVRC_0, 0x3A0, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_LVL2_CLK_GATE_OVRD_0, 0x3A4, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_LVL2_CLK_GATE_OVRE_0, 0x554, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_I2S2_0, 0x100, 0xD0000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_I2S3_0, 0x104, 0xD0000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_SPDIF_OUT_0, 0x108, 0xC0000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_SPDIF_IN_0, 0x10C, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_PWM_0, 0x110, 0xC0000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_SPI2_0, 0x118, 0xC0000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_SPI3_0, 0x11C, 0xC0000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_I2C1_0, 0x124, 0xC0000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_I2C5_0, 0x128, 0xC0000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_SPI1_0, 0x134, 0xC0000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_DISP1_0, 0x138, 0xC0000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_DISP2_0, 0x13C, 0xC0000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_ISP_0, 0x144, 0xC0000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_VI_0, 0x148, 0x80000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_SDMMC1_0, 0x150, 0xC0000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_SDMMC2_0, 0x154, 0xC0000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_SDMMC4_0, 0x164, 0xC0000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_UARTA_0, 0x178, 0xC0000002)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_UARTB_0, 0x17C, 0xC0000002)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_HOST1X_0, 0x180, 0x80000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_I2C2_0, 0x198, 0xC0000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_EMC_0, 0x19C, 0x60180000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_UARTC_0, 0x1A0, 0xC0000002)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_VI_SENSOR_0, 0x1A8, 0x80000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_SPI4_0, 0x1B4, 0xC0000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_I2C3_0, 0x1B8, 0xC0000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_SDMMC3_0, 0x1BC, 0xC0000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_UARTD_0, 0x1C0, 0xC0000002)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_OWR_0, 0x1CC, 0xC0000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_CSITE_0, 0x1D4, 0xC0000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_I2S1_0, 0x1D8, 0xD0000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_DTV_0, 0x1DC, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_TSEC_0, 0x1F4, 0xC0000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SPARE2_0, 0x1FC, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_OUT_ENB_X_0, 0x280, 0x23004780)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_ENB_X_SET_0, 0x284, 0x23000780)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_ENB_X_CLR_0, 0x288, 0x23000780)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_RST_DEVICES_X_0, 0x28C, 0x01E42049)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_RST_DEV_X_SET_0, 0x290, 0x01E42049)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_RST_DEV_X_CLR_0, 0x294, 0x01E42049)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_OUT_ENB_Y_0, 0x298, 0x00000300)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_ENB_Y_SET_0, 0x29C, 0x00000300)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_ENB_Y_CLR_0, 0x2A0, 0x00000300)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_RST_DEVICES_Y_0, 0x2A4, 0x0FE9F0DD)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_RST_DEV_Y_SET_0, 0x2A8, 0x0FE9F0DD)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_RST_DEV_Y_CLR_0, 0x2AC, 0x0FE9F0DD)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_DFLL_BASE_0, 0x2F4, 0x00000001)
    //TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_RST_DEV_L_SET_0, 0x300, 0x1CD3D2C8)
    //TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_RST_DEV_L_CLR_0, 0x304, 0x1CD3D2C8)
    //TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_RST_DEV_H_SET_0, 0x308, 0x87D1F326)
    //TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_RST_DEV_H_CLR_0, 0x30C, 0x87D1F327)
    //TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_RST_DEV_U_SET_0, 0x310, 0x828EC5FA)
    //TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_RST_DEV_U_CLR_0, 0x314, 0x828EC5FA)
    //TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_ENB_L_SET_0, 0x320, 0x80000130)
    //TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_ENB_L_CLR_0, 0x324, 0x80000130)
    //TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_ENB_H_SET_0, 0x328, 0x00000080)
    //TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_ENB_H_CLR_0, 0x32C, 0x00000080)
    //TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_ENB_U_SET_0, 0x330, 0x01F80200)
    //TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_ENB_U_CLR_0, 0x334, 0x01F00200)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CCPLEX_PG_SM_OVRD_0, 0x33C, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_RST_CPU_CMPLX_SET_0, 0x340, 0x2000FEEF)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_RST_DEVICES_V_0, 0x358, 0xFF818080)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_RST_DEVICES_W_0, 0x35C, 0x190077FF)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_OUT_ENB_V_0, 0x360, 0x00400008)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_OUT_ENB_W_0, 0x364, 0x402000FC)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CCLKG_BURST_POLICY_0, 0x368, 0x10000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_SUPER_CCLKG_DIVIDER_0, 0x36C, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CCLKLP_BURST_POLICY_0, 0x370, 0x10000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_SUPER_CCLKLP_DIVIDER_0, 0x374, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_CPUG_CMPLX_0, 0x378, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CPU_SOFTRST_CTRL_0, 0x380, 0x00000010)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CPU_SOFTRST_CTRL1_0, 0x384, 0x00040004)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CPU_SOFTRST_CTRL2_0, 0x388, 0x07000200)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_MSELECT_0, 0x3B4, 0xC0000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_TSENSOR_0, 0x3B8, 0xC0000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_I2S4_0, 0x3BC, 0xD0000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_I2S5_0, 0x3C0, 0xD0000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_I2C4_0, 0x3C4, 0xC0000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_AHUB_0, 0x3D0, 0xD0000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_HDA2CODEC_2X_0, 0x3E4, 0xC0000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_ACTMON_0, 0x3E8, 0xC0000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_EXTPERIPH1_0, 0x3EC, 0x60000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_EXTPERIPH2_0, 0x3F0, 0x60000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_EXTPERIPH3_0, 0x3F4, 0x60000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_I2C_SLOW_0, 0x3FC, 0xC0000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_SYS_0, 0x400, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_ISPB_0, 0x404, 0x80000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_SOR1_0, 0x410, 0xC0000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_SOR0_0, 0x414, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_SATA_OOB_0, 0x420, 0xC0000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_SATA_0, 0x424, 0xC1000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_HDA_0, 0x428, 0xC0000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_RST_DEV_V_SET_0, 0x430, 0xFF818080)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_RST_DEV_V_CLR_0, 0x434, 0xFF818080)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_RST_DEV_W_SET_0, 0x438, 0x190077FF)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_RST_DEV_W_CLR_0, 0x43C, 0x190077FF)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_ENB_V_SET_0, 0x440, 0x00400008)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_ENB_V_CLR_0, 0x444, 0x00400008)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_ENB_W_SET_0, 0x448, 0x402000FC)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_ENB_W_CLR_0, 0x44C, 0x402000FC)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_RST_CPUG_CMPLX_SET_0, 0x450, 0x2000FEEF)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_RST_CPUG_CMPLX_CLR_0, 0x454, 0x2000FEEF)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_CPUG_CMPLX_SET_0, 0x460, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_CPUG_CMPLX_CLR_0, 0x464, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CPU_CMPLX_STATUS_0, 0x470, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_INTSTATUS_0, 0x478, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_INTMASK_0, 0x47C, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_UTMIP_PLL_CFG0_0, 0x480, 0x00190101)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_UTMIP_PLL_CFG1_0, 0x484, 0x180150C0)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_UTMIP_PLL_CFG2_0, 0x488, 0x41318015)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_PLLE_AUX_0, 0x48C, 0x02002070)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_SATA_PLL_CFG0_0, 0x490, 0x02003803)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_SATA_PLL_CFG1_0, 0x494, 0x00011400)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_PCIE_PLL_CFG_0, 0x498, 0x0200000C)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_PROG_AUDIO_DLY_CLK_0, 0x49C, 0x00700000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_AUDIO_SYNC_CLK_I2S1_0, 0x4A0, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_AUDIO_SYNC_CLK_I2S2_0, 0x4A4, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_AUDIO_SYNC_CLK_I2S3_0, 0x4A8, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_AUDIO_SYNC_CLK_I2S4_0, 0x4AC, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_AUDIO_SYNC_CLK_I2S5_0, 0x4B0, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_AUDIO_SYNC_CLK_SPDIF_0, 0x4B4, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_PLLD2_BASE_0, 0x4B8, 0x00041401)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_PLLD2_MISC_0, 0x4BC, 0x40000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_UTMIP_PLL_CFG3_0, 0x4C0, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_PLLREFE_BASE_0, 0x4C4, 0x00004104)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_PLLREFE_MISC_0, 0x4C8, 0x41000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_PLLREFE_OUT_0, 0x4CC, 0x00020002)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CPU_FINETRIM_BYP_0, 0x4D0, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CPU_FINETRIM_SELECT_0, 0x4D4, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CPU_FINETRIM_DR_0, 0x4D8, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CPU_FINETRIM_DF_0, 0x4DC, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CPU_FINETRIM_F_0, 0x4E0, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CPU_FINETRIM_R_0, 0x4E4, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_PLLC2_BASE_0, 0x4E8, 0x00108002)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_PLLC2_MISC_0_0, 0x4EC, 0x40000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_PLLC2_MISC_1_0, 0x4F0, 0x08000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_PLLC2_MISC_2_0, 0x4F4, 0x1F720005)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_PLLC2_MISC_3_0, 0x4F8, 0x000000C4)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_PLLC3_BASE_0, 0x4FC, 0x00108002)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_PLLC3_MISC_0_0, 0x500, 0x40000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_PLLC3_MISC_1_0, 0x504, 0x08000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_PLLC3_MISC_2_0, 0x508, 0x1F720005)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_PLLC3_MISC_3_0, 0x50C, 0x000000C4)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_PLLX_MISC_1_0, 0x510, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_PLLX_MISC_2_0, 0x514, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_PLLX_MISC_3_0, 0x518, 0x00000008)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_XUSBIO_PLL_CFG0_0, 0x51C, 0x0200380D)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_XUSBIO_PLL_CFG1_0, 0x520, 0x00000014)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_PLLE_AUX1_0, 0x524, 0x00000105)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_PLLP_RESHIFT_0, 0x528, 0x00000053)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_UTMIPLL_HW_PWRDN_CFG0_0, 0x52C, 0x0200000F)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_PLLU_HW_PWRDN_CFG0_0, 0x530, 0x0200008D)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_XUSB_PLL_CFG0_0, 0x534, 0x8002A80F)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_CPU_MISC_0, 0x53C, 0x00000002)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_CPUG_MISC_0, 0x540, 0x00000002)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_PLLX_HW_CTRL_CFG_0, 0x548, 0x00000001)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_PLLX_SW_RAMP_CFG_0, 0x54C, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_PLLX_HW_CTRL_STATUS_0, 0x550, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_SPARE_REG0_0, 0x55C, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_AUDIO_SYNC_CLK_DMIC1_0, 0x560, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_AUDIO_SYNC_CLK_DMIC2_0, 0x564, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_PLLD2_SS_CFG_0, 0x570, 0x10000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_PLLD2_SS_CTRL1_0, 0x574, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_PLLD2_SS_CTRL2_0, 0x578, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_PLLDP_BASE_0, 0x590, 0x00041401)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_PLLDP_MISC_0, 0x594, 0x40000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_PLLDP_SS_CFG_0, 0x598, 0x10000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_PLLDP_SS_CTRL1_0, 0x59C, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_PLLDP_SS_CTRL2_0, 0x5A0, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_PLLC4_BASE_0, 0x5A4, 0x000C2302)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_PLLC4_MISC_0, 0x5A8, 0x40000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SPARE0_0, 0x5C4, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SPARE1_0, 0x5C8, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_GPU_ISOB_CTRL_0, 0x5CC, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_PLLC_MISC_2_0, 0x5D0, 0x1F720005)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_PLLC_MISC_3_0, 0x5D4, 0x000000C4)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_PLLA_MISC2_0, 0x5D8, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_PLLC4_OUT_0, 0x5E4, 0x00000002)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_PLLMB_BASE_0, 0x5E8, 0x00002A02)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_PLLMB_MISC1_0, 0x5EC, 0x00010000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_PLLX_MISC_4_0, 0x5F0, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_PLLX_MISC_5_0, 0x5F4, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_XUSB_CORE_HOST_0, 0x600, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_XUSB_FALCON_0, 0x604, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_XUSB_FS_0, 0x608, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_XUSB_CORE_DEV_0, 0x60C, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_XUSB_SS_0, 0x610, 0x04000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_CILAB_0, 0x614, 0xC0000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_CILCD_0, 0x618, 0xC0000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_CILEF_0, 0x61C, 0xC0000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_DSIA_LP_0, 0x620, 0xC0000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_DSIB_LP_0, 0x624, 0xC0000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_ENTROPY_0, 0x628, 0x40000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_DVFS_REF_0, 0x62C, 0xD0000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_DVFS_SOC_0, 0x630, 0xD0000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_EMC_LATENCY_0, 0x640, 0x60000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_SOC_THERM_0, 0x644, 0x40000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_DMIC1_0, 0x64C, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_DMIC2_0, 0x650, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_VI_SENSOR2_0, 0x658, 0x80000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_I2C6_0, 0x65C, 0xC0000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_MIPIBIF_0, 0x660, 0xC0000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_EMC_DLL_0, 0x664, 0x60000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_UART_FST_MIPI_CAL_0, 0x66C, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_VIC_0, 0x678, 0xC0000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_PLLP_OUTC_0, 0x67C, 0x00030000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_PLLP_MISC1_0, 0x680, 0x30000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_EMC_DIV_CLK_SHAPER_CTRL_0, 0x68C, 0x00000C00)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_EMC_PLLC_SHAPER_CTRL_0, 0x690, 0x00000C00)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_SDMMC_LEGACY_TM_0, 0x694, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_NVDEC_0, 0x698, 0xE0000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_NVJPG_0, 0x69C, 0xE0000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_NVENC_0, 0x6A0, 0x80000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_PLLA1_BASE_0, 0x6A4, 0x00108002)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_PLLA1_MISC_0_0, 0x6A8, 0x40000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_PLLA1_MISC_1_0, 0x6AC, 0x08000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_PLLA1_MISC_2_0, 0x6B0, 0x1F720005)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_PLLA1_MISC_3_0, 0x6B4, 0x000000C4)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_AUDIO_SYNC_CLK_DMIC3_0, 0x6B8, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_DMIC3_0, 0x6BC, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_APE_0, 0x6C0, 0xC0000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_QSPI_0, 0x6C4, 0xC0000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_VI_I2C_0, 0x6C8, 0xC0000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_USB2_HSIC_TRK_0, 0x6CC, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_PEX_SATA_USB_RX_BYP_0, 0x6D0, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_MAUD_0, 0x6D4, 0x40000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_TSECB_0, 0x6D8, 0xC0000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_CPUG_MISC1_0, 0x6DC, 0x00000002)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_ACLK_BURST_POLICY_0, 0x6E0, 0x10006666)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_SUPER_ACLK_DIVIDER_0, 0x6E4, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_NVENC_SUPER_CLK_DIVIDER_0, 0x6E8, 0x80000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_VI_SUPER_CLK_DIVIDER_0, 0x6EC, 0x80000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_VIC_SUPER_CLK_DIVIDER_0, 0x6F0, 0x80000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_NVDEC_SUPER_CLK_DIVIDER_0, 0x6F4, 0x80000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_ISP_SUPER_CLK_DIVIDER_0, 0x6F8, 0x80000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_ISPB_SUPER_CLK_DIVIDER_0, 0x6FC, 0x80000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_NVJPG_SUPER_CLK_DIVIDER_0, 0x700, 0x80000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_SE_SUPER_CLK_DIVIDER_0, 0x704, 0x80000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_TSEC_SUPER_CLK_DIVIDER_0, 0x708, 0x80000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_TSECB_SUPER_CLK_DIVIDER_0, 0x70C, 0x80000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_UARTAPE_0, 0x710, 0xC0000002)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_CPUG_MISC2_0, 0x714, 0x00000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_DBGAPB_0, 0x718, 0xC0000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_CCPLEX_CC4_RET_CLK_ENB_0, 0x71C, 0x001FFFFF)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_ACTMON_CPU_CLK_0, 0x720, 0x00000400)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_CLK_SOURCE_EMC_SAFE_0, 0x724, 0x60000000)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_SDMMC2_PLLC4_OUT0_SHAPER_CTRL_0, 0x728, 0x00000C00)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_SDMMC2_PLLC4_OUT1_SHAPER_CTRL_0, 0x72C, 0x00000C00)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_SDMMC2_PLLC4_OUT2_SHAPER_CTRL_0, 0x730, 0x00000C00)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_SDMMC2_DIV_CLK_SHAPER_CTRL_0, 0x734, 0x00000C00)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_SDMMC4_PLLC4_OUT0_SHAPER_CTRL_0, 0x738, 0x00000C00)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_SDMMC4_PLLC4_OUT1_SHAPER_CTRL_0, 0x73C, 0x00000C00)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_SDMMC4_PLLC4_OUT2_SHAPER_CTRL_0, 0x740, 0x00000C00)
    TEGRA_REGDEF_TABLE_RESET(CLK_RST_CONTROLLER_SDMMC4_DIV_CLK_SHAPER_CTRL_0, 0x744, 0x00000C00)
};

int tegra_clk_enabled(int id)
{
    tegra_car *s = tegra_car_dev;
    int ret = 0;

    switch (id) {
    case 0 ... 31:
        ret = s->clk_out_enb_l.reg32 & (1 << id);
        break;
    case 32 ... 63:
        ret = s->clk_out_enb_h.reg32 & (1 << (id - 32));
        break;
    case 64 ... 95:
        ret = s->clk_out_enb_u.reg32 & (1 << (id - 64));
        break;
    default:
        g_assert_not_reached();
    }

    return !!ret;
}

int tegra_rst_asserted(int id)
{
    tegra_car *s = tegra_car_dev;
    int ret = 0;

    switch (id) {
    case 0 ... 31:
        ret = s->rst_devices_l.reg32 & (1 << id);
        break;
    case 32 ... 63:
        ret = s->rst_devices_h.reg32 & (1 << (id - 32));
        break;
    case 64 ... 95:
        ret = s->rst_devices_u.reg32 & (1 << (id - 64));
        break;
    default:
        g_assert_not_reached();
    }

    return !!ret;
}

static void set_rst_devices_l(uint32_t value)
{
    rst_dev_l_set_t rst = { .reg32 = value };

    if (rst.set_cop_rst) {
        tegra_cpu_reset_assert(TEGRA_BPMP);
    }

    if (rst.set_trig_sys_rst) {
        TPRINT("clk_rst reboot request!\n");
        qemu_system_shutdown_request(SHUTDOWN_CAUSE_GUEST_RESET);
    }

    if (rst.set_tmr_rst) {
        TPRINT("car: resetting timers\n");
        for (size_t i=0; i<ARRAY_SIZE(tegra_timer_devs); i++) {
            if (tegra_timer_devs[i]) tegra_device_reset( DEVICE(tegra_timer_devs[i]) );
        }
        tegra_device_reset( DEVICE(tegra_timer_us_dev) );
    }

    if (rst.set_gpio_rst) {
        TPRINT("car: resetting gpio\n");
        tegra_device_reset( DEVICE(tegra_gpios_dev) );
    }

    if (rst.set_vcp_rst) {
        remote_io_rst_set(TEGRA20_CLK_VCP, 1);
    }
}

static void clr_rst_devices_l(uint32_t value)
{
    rst_dev_l_clr_t rst = { .reg32 = value };

    if (rst.clr_cop_rst) {
        tegra_cpu_reset_deassert(TEGRA_BPMP, 0);
    }

    if (rst.clr_vcp_rst) {
        remote_io_rst_set(TEGRA20_CLK_VCP, 0);
    }
}

static void set_rst_devices_h(uint32_t value, uint32_t clk_enb)
{
    rst_dev_h_set_t rst = { .reg32 = value };
    clk_out_enb_h_t clk = { .reg32 = clk_enb };

    if (rst.set_bsea_rst & clk.clk_enb_bsea) {
        TPRINT("car: resetting BSEA\n");
        tegra_device_reset( DEVICE(tegra_bsea_dev) );
    }

    if (rst.set_bsea_rst) {
        remote_io_rst_set(TEGRA20_CLK_BSEA, 1);
    }

    if (rst.set_bsev_rst & clk.clk_enb_bsev) {
        TPRINT("car: resetting BSEV\n");
        tegra_device_reset( DEVICE(tegra_bsev_dev) );
    }

    if (rst.set_bsev_rst) {
        remote_io_rst_set(TEGRA20_CLK_BSEV, 1);
    }

    if (rst.set_vde_rst & clk.clk_enb_vde) {
        TPRINT("car: resetting VDE\n");
        tegra_device_reset( DEVICE(tegra_sxe_dev) );
        tegra_device_reset( DEVICE(tegra_bsev_dev) );
        tegra_device_reset( DEVICE(tegra_mbe_dev) );
        tegra_device_reset( DEVICE(tegra_ppe_dev) );
        tegra_device_reset( DEVICE(tegra_mce_dev) );
        tegra_device_reset( DEVICE(tegra_tfe_dev) );
        tegra_device_reset( DEVICE(tegra_ppb_dev) );
        tegra_device_reset( DEVICE(tegra_vdma_dev) );
        tegra_device_reset( DEVICE(tegra_ucq2_dev) );
        tegra_device_reset( DEVICE(tegra_bsea2_dev) );
        tegra_device_reset( DEVICE(tegra_frameid_dev) );
    }

    if (rst.set_vde_rst) {
        remote_io_rst_set(TEGRA20_CLK_VDE, 1);
    }

    if (rst.set_ahbdma_rst) {
        remote_io_rst_set(TEGRA20_CLK_AHBDMA, 1);
    }
}

static void clr_rst_devices_h(uint32_t value, uint32_t clk_enb)
{
    rst_dev_h_clr_t rst = { .reg32 = value };

    if (rst.clr_bsea_rst) {
        remote_io_rst_set(TEGRA20_CLK_BSEA, 0);
    }

    if (rst.clr_bsev_rst) {
        remote_io_rst_set(TEGRA20_CLK_BSEV, 0);
    }

    if (rst.clr_vde_rst) {
        remote_io_rst_set(TEGRA20_CLK_VDE, 0);
    }

    if (rst.clr_ahbdma_rst) {
        remote_io_rst_set(TEGRA20_CLK_AHBDMA, 0);
    }
}

static void set_rst_devices_u(uint32_t value)
{
}

static void clr_rst_devices_u(uint32_t value)
{
}

static uint64_t tegra_car_priv_read(void *opaque, hwaddr offset,
                                    unsigned size)
{
    tegra_car *s = opaque;
    uint64_t ret = 0;

    switch (offset) {
    case RST_SOURCE_OFFSET:
        ret = s->rst_source.reg32;
        break;
    case RST_DEV_L_SET_OFFSET:
    case RST_DEV_L_CLR_OFFSET:
    case RST_DEVICES_L_OFFSET:
        ret = s->rst_devices_l.reg32;
        break;
    case RST_DEV_H_SET_OFFSET:
    case RST_DEV_H_CLR_OFFSET:
    case RST_DEVICES_H_OFFSET:
        ret = s->rst_devices_h.reg32;
        break;
    case RST_DEV_U_SET_OFFSET:
    case RST_DEV_U_CLR_OFFSET:
    case RST_DEVICES_U_OFFSET:
        ret = s->rst_devices_u.reg32;
        break;
    case CLK_ENB_L_SET_OFFSET:
    case CLK_ENB_L_CLR_OFFSET:
    case CLK_OUT_ENB_L_OFFSET:
        ret = s->clk_out_enb_l.reg32;
        break;
    case CLK_ENB_H_SET_OFFSET:
    case CLK_ENB_H_CLR_OFFSET:
    case CLK_OUT_ENB_H_OFFSET:
        ret = s->clk_out_enb_h.reg32;
        break;
    case CLK_ENB_U_SET_OFFSET:
    case CLK_ENB_U_CLR_OFFSET:
    case CLK_OUT_ENB_U_OFFSET:
        ret = s->clk_out_enb_u.reg32;
        break;
    case CCLK_BURST_POLICY_OFFSET:
        ret = s->cclk_burst_policy.reg32;
        break;
    case SUPER_CCLK_DIVIDER_OFFSET:
        ret = s->super_cclk_divider.reg32;
        break;
    case SCLK_BURST_POLICY_OFFSET:
        ret = s->sclk_burst_policy.reg32;
        break;
    case SUPER_SCLK_DIVIDER_OFFSET:
        ret = s->super_sclk_divider.reg32;
        break;
    case CLK_SYSTEM_RATE_OFFSET:
        ret = s->clk_system_rate.reg32;
        break;
    case PROG_DLY_CLK_OFFSET:
        ret = s->prog_dly_clk.reg32;
        break;
    case AUDIO_SYNC_CLK_RATE_OFFSET:
        ret = s->audio_sync_clk_rate.reg32;
        break;
    case COP_CLK_SKIP_POLICY_OFFSET:
        ret = s->cop_clk_skip_policy.reg32;
        break;
    case CLK_MASK_ARM_OFFSET:
        ret = s->clk_mask_arm.reg32;
        break;
    case MISC_CLK_ENB_OFFSET:
        ret = s->misc_clk_enb.reg32;
        break;
    case CLK_CPU_CMPLX_OFFSET:
        ret = s->clk_cpu_cmplx.reg32;
        break;
    case OSC_CTRL_OFFSET:
        ret = s->osc_ctrl.reg32;
        break;
    case PLL_LFSR_OFFSET:
        ret = s->pll_lfsr.reg32;
        break;
    case OSC_FREQ_DET_OFFSET:
        ret = s->osc_freq_det.reg32;
        break;
    case OSC_FREQ_DET_STATUS_OFFSET:
        ret = s->osc_freq_det_status.reg32;
        break;
    case PLLE_SS_CNTL_OFFSET:
        if (tegra_board >= TEGRAX1_BOARD) ret = s->plle_ss_cntl.reg32;
        break;
    case PLLE_MISC1_OFFSET:
        if (tegra_board >= TEGRAX1_BOARD) ret = s->plle_misc1.reg32;
        break;
    case PLLC_BASE_OFFSET:
        ret = s->pllc_base.reg32;
        break;
    case PLLC_OUT_OFFSET:
        ret = s->pllc_out.reg32;
        break;
    case PLLC_MISC_OFFSET:
        if (tegra_board >= TEGRAX1_BOARD) ret = s->pllc_misc.reg32;
        break;
    case PLLC_MISC_1_OFFSET:
        ret = s->pllc_misc_1.reg32;
        break;
    case PLLM_BASE_OFFSET:
        ret = s->pllm_base.reg32;
        break;
    case PLLM_OUT_OFFSET:
        ret = s->pllm_out.reg32;
        break;
    case PLLM_MISC1_OFFSET:
        if (tegra_board >= TEGRAX1_BOARD) ret = s->pllm_misc1.reg32;
        break;
    case PLLM_MISC2_OFFSET:
        ret = s->pllm_misc2.reg32;
        break;
    case PLLP_BASE_OFFSET:
        ret = s->pllp_base.reg32;
        break;
    case PLLP_OUTA_OFFSET:
        ret = s->pllp_outa.reg32;
        break;
    case PLLP_OUTB_OFFSET:
        ret = s->pllp_outb.reg32;
        break;
    case PLLP_MISC_OFFSET:
        ret = s->pllp_misc.reg32;
        break;
    case PLLA_BASE_OFFSET:
        ret = s->plla_base.reg32;
        break;
    case PLLA_OUT_OFFSET:
        ret = s->plla_out.reg32;
        break;
    case PLLA_MISC1_OFFSET:
        if (tegra_board >= TEGRAX1_BOARD) ret = s->plla_misc1.reg32;
        break;
    case PLLA_MISC_OFFSET:
        ret = s->plla_misc.reg32;
        break;
    case PLLU_BASE_OFFSET:
        ret = s->pllu_base.reg32;
        break;
    case PLLU_OUTA_OFFSET:
        if (tegra_board >= TEGRAX1_BOARD) ret = s->pllu_outa.reg32;
        break;
    case PLLU_MISC1_OFFSET:
        if (tegra_board >= TEGRAX1_BOARD) ret = s->pllu_misc1.reg32;
        break;
    case PLLU_MISC_OFFSET:
        ret = s->pllu_misc.reg32;
        break;
    case PLLD_BASE_OFFSET:
        ret = s->plld_base.reg32;
        break;
    case PLLD_MISC1_OFFSET:
        if (tegra_board >= TEGRAX1_BOARD) ret = s->plld_misc1.reg32;
        break;
    case PLLD_MISC_OFFSET:
        ret = s->plld_misc.reg32;
        break;
    case PLLX_BASE_OFFSET:
        ret = s->pllx_base.reg32;
        break;
    case PLLX_MISC_OFFSET:
        ret = s->pllx_misc.reg32;
        break;
    case PLLE_BASE_OFFSET:
        ret = s->plle_base.reg32;
        break;
    case PLLE_MISC_OFFSET:
        ret = s->plle_misc.reg32;
        break;
    case PLLE_SS_CNTL1_OFFSET:
        if (tegra_board >= TEGRAX1_BOARD) ret = s->plle_ss_cntl1.reg32;
        break;
    case PLLE_SS_CNTL2_OFFSET:
        if (tegra_board >= TEGRAX1_BOARD) ret = s->plle_ss_cntl2.reg32;
        break;
    case LVL2_CLK_GATE_OVRA_OFFSET:
        if (tegra_board >= TEGRAX1_BOARD) ret = s->lvl2_clk_gate_ovra.reg32;
        break;
    case LVL2_CLK_GATE_OVRB_OFFSET:
        if (tegra_board >= TEGRAX1_BOARD) ret = s->lvl2_clk_gate_ovrb.reg32;
        break;
    case CLK_SOURCE_I2S1_OFFSET:
        ret = s->clk_source_i2s1.reg32;
        break;
    case CLK_SOURCE_I2S2_OFFSET:
        ret = s->clk_source_i2s2.reg32;
        break;
    case CLK_SOURCE_SPDIF_OUT_OFFSET:
        ret = s->clk_source_spdif_out.reg32;
        break;
    case CLK_SOURCE_SPDIF_IN_OFFSET:
        ret = s->clk_source_spdif_in.reg32;
        break;
    case CLK_SOURCE_PWM_OFFSET:
        ret = s->clk_source_pwm.reg32;
        break;
    case CLK_SOURCE_SPI1_OFFSET:
        ret = s->clk_source_spi1.reg32;
        break;
    case CLK_SOURCE_SPI22_OFFSET:
        ret = s->clk_source_spi22.reg32;
        break;
    case CLK_SOURCE_SPI3_OFFSET:
        ret = s->clk_source_spi3.reg32;
        break;
    case CLK_SOURCE_XIO_OFFSET:
        ret = s->clk_source_xio.reg32;
        break;
    case CLK_SOURCE_I2C1_OFFSET:
        ret = s->clk_source_i2c1.reg32;
        break;
    case CLK_SOURCE_DVC_I2C_OFFSET:
        ret = s->clk_source_dvc_i2c.reg32;
        break;
    case CLK_SOURCE_TWC_OFFSET:
        ret = s->clk_source_twc.reg32;
        break;
    case CLK_SOURCE_SBC1_OFFSET:
        ret = s->clk_source_sbc1.reg32;
        break;
    case CLK_SOURCE_DISP1_OFFSET:
        ret = s->clk_source_disp1.reg32;
        break;
    case CLK_SOURCE_DISP2_OFFSET:
        ret = s->clk_source_disp2.reg32;
        break;
    case CLK_SOURCE_CVE_OFFSET:
        ret = s->clk_source_cve.reg32;
        break;
    case CLK_SOURCE_IDE_OFFSET:
        ret = s->clk_source_ide.reg32;
        break;
    case CLK_SOURCE_VI_OFFSET:
        ret = s->clk_source_vi.reg32;
        break;
    case CLK_SOURCE_SDMMC1_OFFSET:
        ret = s->clk_source_sdmmc1.reg32;
        break;
    case CLK_SOURCE_SDMMC2_OFFSET:
        ret = s->clk_source_sdmmc2.reg32;
        break;
    case CLK_SOURCE_G3D_OFFSET:
        ret = s->clk_source_g3d.reg32;
        break;
    case CLK_SOURCE_G2D_OFFSET:
        ret = s->clk_source_g2d.reg32;
        break;
    case CLK_SOURCE_NDFLASH_OFFSET:
        ret = s->clk_source_ndflash.reg32;
        break;
    case CLK_SOURCE_SDMMC4_OFFSET:
        ret = s->clk_source_sdmmc4.reg32;
        break;
    case CLK_SOURCE_VFIR_OFFSET:
        ret = s->clk_source_vfir.reg32;
        break;
    case CLK_SOURCE_EPP_OFFSET:
        ret = s->clk_source_epp.reg32;
        break;
    case CLK_SOURCE_MPE_OFFSET:
        ret = s->clk_source_mpe.reg32;
        break;
    case CLK_SOURCE_MIPI_OFFSET:
        ret = s->clk_source_mipi.reg32;
        break;
    case CLK_SOURCE_UART1_OFFSET:
        ret = s->clk_source_uart1.reg32;
        break;
    case CLK_SOURCE_UART2_OFFSET:
        ret = s->clk_source_uart2.reg32;
        break;
    case CLK_SOURCE_HOST1X_OFFSET:
        ret = s->clk_source_host1x.reg32;
        break;
    case CLK_SOURCE_TVO_OFFSET:
        ret = s->clk_source_tvo.reg32;
        break;
    case CLK_SOURCE_HDMI_OFFSET:
        ret = s->clk_source_hdmi.reg32;
        break;
    case CLK_SOURCE_TVDAC_OFFSET:
        ret = s->clk_source_tvdac.reg32;
        break;
    case CLK_SOURCE_I2C2_OFFSET:
        ret = s->clk_source_i2c2.reg32;
        break;
    case CLK_SOURCE_EMC_OFFSET:
        ret = s->clk_source_emc.reg32;
        break;
    case CLK_SOURCE_UART3_OFFSET:
        ret = s->clk_source_uart3.reg32;
        break;
    case CLK_SOURCE_VI_SENSOR_OFFSET:
        ret = s->clk_source_vi_sensor.reg32;
        break;
    case CLK_SOURCE_SPI4_OFFSET:
        ret = s->clk_source_spi4.reg32;
        break;
    case CLK_SOURCE_I2C3_OFFSET:
        ret = s->clk_source_i2c3.reg32;
        break;
    case CLK_SOURCE_SDMMC3_OFFSET:
        ret = s->clk_source_sdmmc3.reg32;
        break;
    case CLK_SOURCE_UART4_OFFSET:
        ret = s->clk_source_uart4.reg32;
        break;
    case CLK_SOURCE_UART5_OFFSET:
        ret = s->clk_source_uart5.reg32;
        break;
    case CLK_SOURCE_VDE_OFFSET:
        ret = s->clk_source_vde.reg32;
        break;
    case CLK_SOURCE_OWR_OFFSET:
        ret = s->clk_source_owr.reg32;
        break;
    case CLK_SOURCE_NOR_OFFSET:
        ret = s->clk_source_nor.reg32;
        break;
    case CLK_SOURCE_CSITE_OFFSET:
        ret = s->clk_source_csite.reg32;
        break;
    case CLK_SOURCE_OSC_OFFSET:
        ret = s->clk_source_osc.reg32;
        break;
    case RST_CPU_CMPLX_SET_OFFSET:
    case RST_CPUG_CMPLX_SET_OFFSET:
        ret = s->rst_cpu_cmplx_set.reg32;
        break;
    case CPU_CMPLX_STATUS_OFFSET:
        ret = s->cpu_cmplx_status.reg32;
        break;
    case UTMIP_PLL_CFG0_OFFSET:
        if (tegra_board >= TEGRAX1_BOARD) ret = s->utmip_pll_cfg0.reg32;
        break;
    case RST_CONTROLLER_PLLC4_BASE_OFFSET:
        if (tegra_board >= TEGRAX1_BOARD) ret = s->rst_controller_pllc4_base.reg32;
        break;
    case RST_CONTROLLER_PLLMB_BASE_OFFSET:
        if (tegra_board >= TEGRAX1_BOARD) ret = s->rst_controller_pllmb_base.reg32;
        break;
    case CLK_SOURCE_LA_OFFSET:
        ret = s->clk_source_la.reg32;
        break;
    default:
        if (offset == s->rst_cpu_cmplx_clr_offset) ret = s->rst_cpu_cmplx_clr.reg32;
        else if (tegra_board >= TEGRAX1_BOARD && offset <= sizeof(s->regs)-4) ret = s->regs[offset>>2];
        break;
    }

    TRACE_READ(s->iomem.addr, offset, ret);

    return ret;
}

static void tegra_car_priv_write(void *opaque, hwaddr offset,
                                 uint64_t value, unsigned size)
{
    tegra_car *s = opaque;

    switch (offset) {
    case RST_SOURCE_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->rst_source.reg32, value & RST_SOURCE_WRMASK);
        WR_MASKED(s->rst_source.reg32, value, RST_SOURCE);
        break;
    case RST_DEVICES_L_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->rst_devices_l.reg32, value);

        set_rst_devices_l(((s->rst_devices_l.reg32 ^ value) & value) & (s->clk_out_enb_l.reg32 | 6));
        clr_rst_devices_l(((s->rst_devices_l.reg32 ^ value) & value) & (s->clk_out_enb_l.reg32 | 6));
        s->rst_devices_l.reg32 = value;
        break;
    case RST_DEVICES_H_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->rst_devices_h.reg32, value);

        set_rst_devices_h(((s->rst_devices_h.reg32 ^ value) & value), s->clk_out_enb_h.reg32);
        clr_rst_devices_h(((s->rst_devices_h.reg32 ^ value) & value), s->clk_out_enb_h.reg32);
        s->rst_devices_h.reg32 = value;
        break;
    case RST_DEVICES_U_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->rst_devices_u.reg32, value);

        set_rst_devices_u(((s->rst_devices_u.reg32 ^ value) & value) & s->clk_out_enb_u.reg32);
        clr_rst_devices_u(((s->rst_devices_u.reg32 ^ value) & value) & s->clk_out_enb_u.reg32);
        s->rst_devices_u.reg32 = value;
        break;
    case CLK_OUT_ENB_L_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->clk_out_enb_l.reg32, value);
        s->clk_out_enb_l.reg32 = value;

        remote_io_clk_set(TEGRA20_CLK_VCP, s->clk_out_enb_l.clk_enb_vcp);

        set_rst_devices_l(((s->clk_out_enb_l.reg32 & (value | 6)) ^ value) & s->rst_devices_l.reg32);
        break;
    case CLK_OUT_ENB_H_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->clk_out_enb_h.reg32, value);
        s->clk_out_enb_h.reg32 = value;

        remote_io_clk_set(TEGRA20_CLK_AHBDMA, s->clk_out_enb_h.clk_enb_ahbdma);
        remote_io_clk_set(TEGRA20_CLK_BSEA, s->clk_out_enb_h.clk_enb_bsea);
        remote_io_clk_set(TEGRA20_CLK_BSEV, s->clk_out_enb_h.clk_enb_bsev);
        remote_io_clk_set(TEGRA20_CLK_VDE, s->clk_out_enb_h.clk_enb_vde);

        set_rst_devices_h(((s->clk_out_enb_h.reg32 & value) ^ value), s->rst_devices_h.reg32);
        break;
    case CLK_OUT_ENB_U_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->clk_out_enb_u.reg32, value);
        s->clk_out_enb_u.reg32 = value;

        set_rst_devices_u(((s->clk_out_enb_u.reg32 & value) ^ value) & s->rst_devices_u.reg32);
        break;
    case CCLK_BURST_POLICY_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->cclk_burst_policy.reg32, value);
        s->cclk_burst_policy.reg32 = value;
        break;
    case SUPER_CCLK_DIVIDER_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->super_cclk_divider.reg32, value);
        s->super_cclk_divider.reg32 = value;
        break;
    case SCLK_BURST_POLICY_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->sclk_burst_policy.reg32, value);
        s->sclk_burst_policy.reg32 = value;
        break;
    case SUPER_SCLK_DIVIDER_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->super_sclk_divider.reg32, value);
        s->super_sclk_divider.reg32 = value;
        break;
    case CLK_SYSTEM_RATE_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->clk_system_rate.reg32, value);
        s->clk_system_rate.reg32 = value;
        break;
    case PROG_DLY_CLK_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->prog_dly_clk.reg32, value);
        s->prog_dly_clk.reg32 = value;
        break;
    case AUDIO_SYNC_CLK_RATE_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->audio_sync_clk_rate.reg32, value);
        s->audio_sync_clk_rate.reg32 = value;
        break;
    case COP_CLK_SKIP_POLICY_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->cop_clk_skip_policy.reg32, value);
        s->cop_clk_skip_policy.reg32 = value;
        break;
    case CLK_MASK_ARM_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->clk_mask_arm.reg32, value & CLK_MASK_ARM_WRMASK);
        WR_MASKED(s->clk_mask_arm.reg32, value, CLK_MASK_ARM);
        break;
    case MISC_CLK_ENB_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->misc_clk_enb.reg32, value);
        s->misc_clk_enb.reg32 = value;
        break;
    case CLK_CPU_CMPLX_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->clk_cpu_cmplx.reg32, value);
        s->clk_cpu_cmplx.reg32 = value;
        break;
    case OSC_CTRL_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->osc_ctrl.reg32, value);
        s->osc_ctrl.reg32 = value;
        break;
    case OSC_FREQ_DET_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->osc_freq_det.reg32, value);
        value &= ~(1<<31); // Clear ENABLE.
        s->osc_freq_det.reg32 = value;
        break;
    case PLLE_SS_CNTL_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->plle_ss_cntl.reg32, value);
        if (tegra_board >= TEGRAX1_BOARD) s->plle_ss_cntl.reg32 = value;
        break;
    case PLLE_MISC1_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->plle_misc1.reg32, value);
        if (tegra_board >= TEGRAX1_BOARD) s->plle_misc1.reg32 = value;
        break;
    case PLLC_BASE_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->pllc_base.reg32, value & PLLC_BASE_WRMASK);
        WR_MASKED(s->pllc_base.reg32, value, PLLC_BASE);
        break;
    case PLLC_OUT_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->pllc_out.reg32, value);
        s->pllc_out.reg32 = value;
        break;
    case PLLC_MISC_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->pllc_misc.reg32, value);
        if (tegra_board >= TEGRAX1_BOARD) s->pllc_misc.reg32 = value;
        break;
    case PLLC_MISC_1_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->pllc_misc_1.reg32, value);
        s->pllc_misc_1.reg32 = value;
        break;
    case PLLM_BASE_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->pllm_base.reg32, value & PLLM_BASE_WRMASK);
        WR_MASKED(s->pllm_base.reg32, value, PLLM_BASE);
        break;
    case PLLM_OUT_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->pllm_out.reg32, value);
        s->pllm_out.reg32 = value;
        break;
    case PLLM_MISC1_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->pllm_misc1.reg32, value);
        if (tegra_board >= TEGRAX1_BOARD) s->pllm_misc1.reg32 = value;
        break;
    case PLLM_MISC2_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->pllm_misc2.reg32, value);
        s->pllm_misc2.reg32 = value;
        break;
    case PLLP_BASE_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->pllp_base.reg32, value & PLLP_BASE_WRMASK);
        WR_MASKED(s->pllp_base.reg32, value, PLLP_BASE);
        break;
    case PLLP_OUTA_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->pllp_outa.reg32, value);
        s->pllp_outa.reg32 = value;
        break;
    case PLLP_OUTB_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->pllp_outb.reg32, value);
        s->pllp_outb.reg32 = value;
        break;
    case PLLP_MISC_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->pllp_misc.reg32, value);
        s->pllp_misc.reg32 = value;
        break;
    case PLLA_BASE_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->plla_base.reg32, value & PLLA_BASE_WRMASK);
        WR_MASKED(s->plla_base.reg32, value, PLLA_BASE);
        break;
    case PLLA_OUT_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->plla_out.reg32, value);
        s->plla_out.reg32 = value;
        break;
    case PLLA_MISC1_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->plla_misc1.reg32, value);
        if (tegra_board >= TEGRAX1_BOARD) s->plla_misc1.reg32 = value;
        break;
    case PLLA_MISC_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->plla_misc.reg32, value);
        s->plla_misc.reg32 = value;
        break;
    case PLLU_BASE_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->pllu_base.reg32, value & PLLU_BASE_WRMASK);
        WR_MASKED(s->pllu_base.reg32, value, PLLU_BASE);
        break;
    case PLLU_OUTA_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->pllu_outa.reg32, value);
        if (tegra_board >= TEGRAX1_BOARD) s->pllu_outa.reg32 = value;
        break;
    case PLLU_MISC1_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->pllu_misc1.reg32, value);
        if (tegra_board >= TEGRAX1_BOARD) s->pllu_misc1.reg32 = value;
        break;
    case PLLU_MISC_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->pllu_misc.reg32, value);
        s->pllu_misc.reg32 = value;
        break;
    case PLLD_BASE_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->plld_base.reg32, value & PLLD_BASE_WRMASK);
        WR_MASKED(s->plld_base.reg32, value, PLLD_BASE);
        break;
    case PLLD_MISC1_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->plld_misc1.reg32, value);
        if (tegra_board >= TEGRAX1_BOARD) s->plld_misc1.reg32 = value;
        break;
    case PLLD_MISC_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->plld_misc.reg32, value);
        s->plld_misc.reg32 = value;
        break;
    case PLLX_BASE_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->pllx_base.reg32, value & PLLX_BASE_WRMASK);
        WR_MASKED(s->pllx_base.reg32, value, PLLX_BASE);
        break;
    case PLLX_MISC_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->pllx_misc.reg32, value);
        s->pllx_misc.reg32 = value;
        break;
    case PLLE_BASE_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->plle_base.reg32, value);
        s->plle_base.reg32 = value;
        break;
    case PLLE_MISC_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->plle_misc.reg32, value & PLLE_MISC_WRMASK);
        WR_MASKED(s->plle_misc.reg32, value, PLLE_MISC);
        break;
    case PLLE_SS_CNTL1_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->plle_ss_cntl1.reg32, value);
        if (tegra_board >= TEGRAX1_BOARD) s->plle_ss_cntl1.reg32 = value;
        break;
    case PLLE_SS_CNTL2_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->plle_ss_cntl2.reg32, value);
        if (tegra_board >= TEGRAX1_BOARD) s->plle_ss_cntl2.reg32 = value;
        break;
    case LVL2_CLK_GATE_OVRA_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->lvl2_clk_gate_ovra.reg32, value);
        if (tegra_board >= TEGRAX1_BOARD) s->lvl2_clk_gate_ovra.reg32 = value;
        break;
    case LVL2_CLK_GATE_OVRB_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->lvl2_clk_gate_ovrb.reg32, value);
        if (tegra_board >= TEGRAX1_BOARD) s->lvl2_clk_gate_ovrb.reg32 = value;
        break;
    case CLK_SOURCE_I2S1_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->clk_source_i2s1.reg32, value);
        s->clk_source_i2s1.reg32 = value;
        break;
    case CLK_SOURCE_I2S2_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->clk_source_i2s2.reg32, value);
        s->clk_source_i2s2.reg32 = value;
        break;
    case CLK_SOURCE_SPDIF_OUT_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->clk_source_spdif_out.reg32, value);
        s->clk_source_spdif_out.reg32 = value;
        break;
    case CLK_SOURCE_SPDIF_IN_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->clk_source_spdif_in.reg32, value);
        s->clk_source_spdif_in.reg32 = value;
        break;
    case CLK_SOURCE_PWM_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->clk_source_pwm.reg32, value);
        s->clk_source_pwm.reg32 = value;
        break;
    case CLK_SOURCE_SPI1_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->clk_source_spi1.reg32, value);
        s->clk_source_spi1.reg32 = value;
        break;
    case CLK_SOURCE_SPI22_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->clk_source_spi22.reg32, value);
        s->clk_source_spi22.reg32 = value;
        break;
    case CLK_SOURCE_SPI3_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->clk_source_spi3.reg32, value);
        s->clk_source_spi3.reg32 = value;
        break;
    case CLK_SOURCE_XIO_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->clk_source_xio.reg32, value);
        s->clk_source_xio.reg32 = value;
        break;
    case CLK_SOURCE_I2C1_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->clk_source_i2c1.reg32, value);
        s->clk_source_i2c1.reg32 = value;
        break;
    case CLK_SOURCE_DVC_I2C_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->clk_source_dvc_i2c.reg32, value);
        s->clk_source_dvc_i2c.reg32 = value;
        break;
    case CLK_SOURCE_TWC_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->clk_source_twc.reg32, value);
        s->clk_source_twc.reg32 = value;
        break;
    case CLK_SOURCE_SBC1_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->clk_source_sbc1.reg32, value);
        s->clk_source_sbc1.reg32 = value;
        break;
    case CLK_SOURCE_DISP1_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->clk_source_disp1.reg32, value);
        s->clk_source_disp1.reg32 = value;
        break;
    case CLK_SOURCE_DISP2_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->clk_source_disp2.reg32, value);
        s->clk_source_disp2.reg32 = value;
        break;
    case CLK_SOURCE_CVE_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->clk_source_cve.reg32, value);
        s->clk_source_cve.reg32 = value;
        break;
    case CLK_SOURCE_IDE_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->clk_source_ide.reg32, value);
        s->clk_source_ide.reg32 = value;
        break;
    case CLK_SOURCE_VI_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->clk_source_vi.reg32, value);
        s->clk_source_vi.reg32 = value;
        break;
    case CLK_SOURCE_SDMMC1_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->clk_source_sdmmc1.reg32, value);
        s->clk_source_sdmmc1.reg32 = value;
        break;
    case CLK_SOURCE_SDMMC2_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->clk_source_sdmmc2.reg32, value);
        s->clk_source_sdmmc2.reg32 = value;
        break;
    case CLK_SOURCE_G3D_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->clk_source_g3d.reg32, value);
        s->clk_source_g3d.reg32 = value;
        break;
    case CLK_SOURCE_G2D_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->clk_source_g2d.reg32, value);
        s->clk_source_g2d.reg32 = value;
        break;
    case CLK_SOURCE_NDFLASH_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->clk_source_ndflash.reg32, value);
        s->clk_source_ndflash.reg32 = value;
        break;
    case CLK_SOURCE_SDMMC4_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->clk_source_sdmmc4.reg32, value);
        s->clk_source_sdmmc4.reg32 = value;
        break;
    case CLK_SOURCE_VFIR_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->clk_source_vfir.reg32, value);
        s->clk_source_vfir.reg32 = value;
        break;
    case CLK_SOURCE_EPP_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->clk_source_epp.reg32, value);
        s->clk_source_epp.reg32 = value;
        break;
    case CLK_SOURCE_MPE_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->clk_source_mpe.reg32, value);
        s->clk_source_mpe.reg32 = value;
        break;
    case CLK_SOURCE_MIPI_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->clk_source_mipi.reg32, value);
        s->clk_source_mipi.reg32 = value;
        break;
    case CLK_SOURCE_UART1_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->clk_source_uart1.reg32, value);
        s->clk_source_uart1.reg32 = value;
        break;
    case CLK_SOURCE_UART2_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->clk_source_uart2.reg32, value);
        s->clk_source_uart2.reg32 = value;
        break;
    case CLK_SOURCE_HOST1X_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->clk_source_host1x.reg32, value);
        s->clk_source_host1x.reg32 = value;
        break;
    case CLK_SOURCE_TVO_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->clk_source_tvo.reg32, value);
        s->clk_source_tvo.reg32 = value;
        break;
    case CLK_SOURCE_HDMI_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->clk_source_hdmi.reg32, value);
        s->clk_source_hdmi.reg32 = value;
        break;
    case CLK_SOURCE_TVDAC_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->clk_source_tvdac.reg32, value);
        s->clk_source_tvdac.reg32 = value;
        break;
    case CLK_SOURCE_I2C2_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->clk_source_i2c2.reg32, value);
        s->clk_source_i2c2.reg32 = value;
        break;
    case CLK_SOURCE_EMC_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->clk_source_emc.reg32, value);
        s->clk_source_emc.reg32 = value;
        break;
    case CLK_SOURCE_UART3_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->clk_source_uart3.reg32, value);
        s->clk_source_uart3.reg32 = value;
        break;
    case CLK_SOURCE_VI_SENSOR_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->clk_source_vi_sensor.reg32, value);
        s->clk_source_vi_sensor.reg32 = value;
        break;
    case CLK_SOURCE_SPI4_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->clk_source_spi4.reg32, value);
        s->clk_source_spi4.reg32 = value;
        break;
    case CLK_SOURCE_I2C3_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->clk_source_i2c3.reg32, value);
        s->clk_source_i2c3.reg32 = value;
        break;
    case CLK_SOURCE_SDMMC3_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->clk_source_sdmmc3.reg32, value);
        s->clk_source_sdmmc3.reg32 = value;
        break;
    case CLK_SOURCE_UART4_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->clk_source_uart4.reg32, value);
        s->clk_source_uart4.reg32 = value;
        break;
    case CLK_SOURCE_UART5_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->clk_source_uart5.reg32, value);
        s->clk_source_uart5.reg32 = value;
        break;
    case CLK_SOURCE_VDE_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->clk_source_vde.reg32, value);
        s->clk_source_vde.reg32 = value;
        break;
    case CLK_SOURCE_OWR_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->clk_source_owr.reg32, value);
        s->clk_source_owr.reg32 = value;
        break;
    case CLK_SOURCE_NOR_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->clk_source_nor.reg32, value);
        s->clk_source_nor.reg32 = value;
        break;
    case CLK_SOURCE_CSITE_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->clk_source_csite.reg32, value);
        s->clk_source_csite.reg32 = value;
        break;
    case CLK_SOURCE_OSC_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->clk_source_osc.reg32, value);
        s->clk_source_osc.reg32 = value;
        break;
    case RST_DEV_L_SET_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->rst_devices_l.reg32, value);

        set_rst_devices_l(((s->rst_devices_l.reg32 & value) ^ value) & (s->clk_out_enb_l.reg32 | 6));
        s->rst_devices_l.reg32 |= value;
        break;
    case RST_DEV_L_CLR_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->rst_devices_l.reg32, value);

        clr_rst_devices_l(s->rst_devices_l.reg32 & value & (s->clk_out_enb_l.reg32 | 6));
        s->rst_devices_l.reg32 &= ~value;
        break;
    case RST_DEV_H_SET_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->rst_devices_h.reg32, value);

        set_rst_devices_h(((s->rst_devices_h.reg32 & value) ^ value), s->clk_out_enb_h.reg32);
        s->rst_devices_h.reg32 |= value;
        break;
    case RST_DEV_H_CLR_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->rst_devices_h.reg32, value);

        clr_rst_devices_h(s->rst_devices_h.reg32 & value, s->clk_out_enb_h.reg32);
        s->rst_devices_h.reg32 &= ~value;
        break;
    case RST_DEV_U_SET_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->rst_devices_u.reg32, value);

        set_rst_devices_u(((s->rst_devices_u.reg32 & value) ^ value) & s->clk_out_enb_u.reg32);
        s->rst_devices_u.reg32 |= value;
        break;
    case RST_DEV_U_CLR_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->rst_devices_u.reg32, value);

        clr_rst_devices_u(s->rst_devices_u.reg32 & value & s->clk_out_enb_u.reg32);
        s->rst_devices_u.reg32 &= ~value;
        break;
    case CLK_ENB_L_SET_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->clk_out_enb_l.reg32, value);

        set_rst_devices_l(((s->clk_out_enb_l.reg32 & (value | 6)) ^ value) & s->rst_devices_l.reg32);
        s->clk_out_enb_l.reg32 |= value;

        remote_io_clk_set(TEGRA20_CLK_VCP, s->clk_out_enb_l.clk_enb_vcp);
        break;
    case CLK_ENB_L_CLR_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->clk_out_enb_l.reg32, value);
        s->clk_out_enb_l.reg32 &= ~value;

        remote_io_clk_set(TEGRA20_CLK_VCP, s->clk_out_enb_l.clk_enb_vcp);
        break;
    case CLK_ENB_H_SET_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->clk_out_enb_h.reg32, value);

        set_rst_devices_h(((s->clk_out_enb_h.reg32 & value) ^ value), s->rst_devices_h.reg32);
        s->clk_out_enb_h.reg32 |= value;

        remote_io_clk_set(TEGRA20_CLK_AHBDMA, s->clk_out_enb_h.clk_enb_ahbdma);
        remote_io_clk_set(TEGRA20_CLK_BSEA, s->clk_out_enb_h.clk_enb_bsea);
        remote_io_clk_set(TEGRA20_CLK_BSEV, s->clk_out_enb_h.clk_enb_bsev);
        remote_io_clk_set(TEGRA20_CLK_VDE, s->clk_out_enb_h.clk_enb_vde);
        break;
    case CLK_ENB_H_CLR_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->clk_out_enb_h.reg32, value);
        s->clk_out_enb_h.reg32 &= ~value;

        remote_io_clk_set(TEGRA20_CLK_AHBDMA, s->clk_out_enb_h.clk_enb_ahbdma);
        remote_io_clk_set(TEGRA20_CLK_BSEA, s->clk_out_enb_h.clk_enb_bsea);
        remote_io_clk_set(TEGRA20_CLK_BSEV, s->clk_out_enb_h.clk_enb_bsev);
        remote_io_clk_set(TEGRA20_CLK_VDE, s->clk_out_enb_h.clk_enb_vde);
        break;
    case CLK_ENB_U_SET_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->clk_out_enb_u.reg32, value);

        set_rst_devices_u(((s->clk_out_enb_u.reg32 & value) ^ value) & s->rst_devices_u.reg32);
        s->clk_out_enb_u.reg32 |= value;
        break;
    case CLK_ENB_U_CLR_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->clk_out_enb_u.reg32, value);
        s->clk_out_enb_u.reg32 &= ~value;
        break;
    case RST_CPU_CMPLX_SET_OFFSET:
    case RST_CPUG_CMPLX_SET_OFFSET:
    {
        TRACE_WRITE(s->iomem.addr, offset, 0, value);
        rst_cpu_cmplx_set_t rst = { .reg32 = value };

        s->cpu_cmplx_status.reg32 |= value;
        s->rst_cpu_cmplx_set.reg32 = value;

        if (rst.set_cpureset0) {
            tegra_cpu_reset_assert(TEGRA_CCPLEX_CORE0);
        }

        if (rst.set_cpureset1) {
            tegra_cpu_reset_assert(TEGRA_CCPLEX_CORE1);
        }

        if (tegra_board >= TEGRAX1_BOARD) {
            if (rst.set_cpureset2) {
                tegra_cpu_reset_assert(TEGRA_CCPLEX_CORE2);
            }

            if (rst.set_cpureset3) {
                tegra_cpu_reset_assert(TEGRA_CCPLEX_CORE3);
            }
        }
        break;
    }
    case UTMIP_PLL_CFG0_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->utmip_pll_cfg0.reg32, value);
        if (tegra_board >= TEGRAX1_BOARD) s->utmip_pll_cfg0.reg32 = value;
        break;
    case RST_CONTROLLER_PLLC4_BASE_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->rst_controller_pllc4_base.reg32, value);
        if (tegra_board >= TEGRAX1_BOARD) s->rst_controller_pllc4_base.reg32 = value;
        break;
    case RST_CONTROLLER_PLLMB_BASE_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->rst_controller_pllmb_base.reg32, value);
        if (tegra_board >= TEGRAX1_BOARD)  {
            value &= ~(3<<26);
            value |= s->rst_controller_pllmb_base.reg32 & (3<<26);
            s->rst_controller_pllmb_base.reg32 = value;
        }
        break;
    case CLK_SOURCE_LA_OFFSET:
        TRACE_WRITE(s->iomem.addr, offset, s->clk_source_la.reg32, value);
        s->clk_source_la.reg32 = value;
        break;
    default:
        if (offset != s->rst_cpu_cmplx_clr_offset && offset <= sizeof(s->regs)-4) {
            TRACE_WRITE(s->iomem.addr, offset, s->regs[offset>>2], value);
            if (offset == CLK_OUT_ENB_X_OFFSET) {
                value |= s->regs[offset>>2] & 0x4000;
            }
            else if (offset >= RST_DEV_V_SET_OFFSET && offset <= CLK_ENB_W_CLR_OFFSET) {
                uint32_t off = (((offset - RST_DEV_V_SET_OFFSET)>>3)<<2) + RST_DEVICES_V_OFFSET;
                if ((offset & 0x4) == 0)
                    s->regs[off>>2] |= value;
                else
                    s->regs[off>>2] &= ~value;
            }
            s->regs[offset>>2] = value;
        }
        else TRACE_WRITE(s->iomem.addr, offset, 0, value);
        break;
    }

    if (offset == s->rst_cpu_cmplx_clr_offset) {
        rst_cpu_cmplx_clr_t rst = { .reg32 = value };

        s->cpu_cmplx_status.reg32 &= ~value;
        s->rst_cpu_cmplx_clr.reg32 = value;

        if (rst.clr_cpureset0) {
            tegra_cpu_reset_deassert(TEGRA_CCPLEX_CORE0, 0);
        }

        if (rst.clr_cpureset1) {
            tegra_cpu_reset_deassert(TEGRA_CCPLEX_CORE1, 0);
        }

        if (tegra_board >= TEGRAX1_BOARD) {
            if (rst.clr_cpureset2) {
                tegra_cpu_reset_deassert(TEGRA_CCPLEX_CORE2, 0);
            }

            if (rst.clr_cpureset3) {
                tegra_cpu_reset_deassert(TEGRA_CCPLEX_CORE3, 0);
            }
        }
    }
}

void tegra_car_orr_reg(void *opaque, hwaddr offset,
                       uint64_t value, unsigned size)
{
    tegra_car_priv_write(opaque, offset, tegra_car_priv_read(opaque, offset, 4) | value, 4);
}

void tegra_car_clear_reg(void *opaque, hwaddr offset,
                         uint64_t value, unsigned size)
{
    tegra_car_priv_write(opaque, offset, tegra_car_priv_read(opaque, offset, 4) & ~value, 4);
}

static void tegra_car_priv_reset(DeviceState *dev)
{
    tegra_car *s = TEGRA_CAR(dev);

    s->rst_source.reg32 = RST_SOURCE_RESET;
    s->rst_devices_l.reg32 = RST_DEVICES_L_RESET;
    s->rst_devices_h.reg32 = RST_DEVICES_H_RESET;
    s->rst_devices_u.reg32 = RST_DEVICES_U_RESET;
    s->clk_out_enb_l.reg32 = CLK_OUT_ENB_L_RESET;
    s->clk_out_enb_h.reg32 = CLK_OUT_ENB_H_RESET;
    s->clk_out_enb_u.reg32 = CLK_OUT_ENB_U_RESET;
    s->cclk_burst_policy.reg32 = CCLK_BURST_POLICY_RESET;
    s->super_cclk_divider.reg32 = SUPER_CCLK_DIVIDER_RESET;
    s->sclk_burst_policy.reg32 = SCLK_BURST_POLICY_RESET;
    s->super_sclk_divider.reg32 = SUPER_SCLK_DIVIDER_RESET;
    s->clk_system_rate.reg32 = CLK_SYSTEM_RATE_RESET;
    s->prog_dly_clk.reg32 = PROG_DLY_CLK_RESET;
    s->audio_sync_clk_rate.reg32 = AUDIO_SYNC_CLK_RATE_RESET;
    s->cop_clk_skip_policy.reg32 = COP_CLK_SKIP_POLICY_RESET;
    s->clk_mask_arm.reg32 = CLK_MASK_ARM_RESET;
    s->misc_clk_enb.reg32 = MISC_CLK_ENB_RESET;
    s->clk_cpu_cmplx.reg32 = CLK_CPU_CMPLX_RESET;
    s->osc_ctrl.reg32 = OSC_CTRL_RESET;
    s->pll_lfsr.reg32 = PLL_LFSR_RESET;
    s->osc_freq_det.reg32 = OSC_FREQ_DET_RESET;
    s->osc_freq_det_status.reg32 = OSC_FREQ_DET_STATUS_RESET;
    s->plle_ss_cntl.reg32 = PLLE_SS_CNTL_RESET;
    s->plle_misc1.reg32 = PLLE_MISC1_OFFSET;
    s->pllc_base.reg32 = PLLC_BASE_RESET | PLL_LOCKED;
    s->pllc_out.reg32 = PLLC_OUT_RESET;
    s->pllc_misc.reg32 = PLLC_MISC_RESET;
    s->pllm_base.reg32 = PLLM_BASE_RESET | PLL_LOCKED;
    s->pllm_out.reg32 = PLLM_OUT_RESET;
    s->pllm_misc1.reg32 = PLLM_MISC1_RESET;
    s->pllp_base.reg32 = PLLP_BASE_RESET | PLL_LOCKED;
    s->pllp_outa.reg32 = PLLP_OUTA_RESET;
    s->pllp_outb.reg32 = PLLP_OUTB_RESET;
    s->pllp_misc.reg32 = PLLP_MISC_RESET;
    s->plla_base.reg32 = PLLA_BASE_RESET | PLL_LOCKED;
    s->plla_out.reg32 = PLLA_OUT_RESET;
    s->plla_misc1.reg32 = PLLA_MISC1_RESET;
    s->pllu_outa.reg32 = PLLU_OUTA_RESET;
    s->pllu_misc1.reg32 = PLLU_MISC1_RESET;
    s->plld_base.reg32 = PLLD_BASE_RESET | PLL_LOCKED;
    s->plld_misc1.reg32 = PLLD_MISC1_RESET;
    s->plld_misc.reg32 = PLLD_MISC_RESET;
    s->pllx_base.reg32 = PLLX_BASE_RESET | PLL_LOCKED;
    s->pllx_misc.reg32 = PLLX_MISC_RESET;
    s->plle_base.reg32 = PLLE_BASE_RESET | PLL_LOCKED;
    s->plle_misc.reg32 = PLLE_MISC_RESET;
    s->plle_ss_cntl1.reg32 = PLLE_SS_CNTL1_RESET;
    s->plle_ss_cntl2.reg32 = PLLE_SS_CNTL2_RESET;
    s->lvl2_clk_gate_ovra.reg32 = LVL2_CLK_GATE_OVRA_RESET;
    s->lvl2_clk_gate_ovrb.reg32 = LVL2_CLK_GATE_OVRB_RESET;
    s->clk_source_i2s1.reg32 = CLK_SOURCE_I2S1_RESET;
    s->clk_source_i2s2.reg32 = CLK_SOURCE_I2S2_RESET;
    s->clk_source_spdif_out.reg32 = CLK_SOURCE_SPDIF_OUT_RESET;
    s->clk_source_spdif_in.reg32 = CLK_SOURCE_SPDIF_IN_RESET;
    s->clk_source_pwm.reg32 = CLK_SOURCE_PWM_RESET;
    s->clk_source_spi1.reg32 = CLK_SOURCE_SPI1_RESET;
    s->clk_source_spi22.reg32 = CLK_SOURCE_SPI22_RESET;
    s->clk_source_spi3.reg32 = CLK_SOURCE_SPI3_RESET;
    s->clk_source_xio.reg32 = CLK_SOURCE_XIO_RESET;
    s->clk_source_i2c1.reg32 = CLK_SOURCE_I2C1_RESET;
    s->clk_source_dvc_i2c.reg32 = CLK_SOURCE_DVC_I2C_RESET;
    s->clk_source_twc.reg32 = CLK_SOURCE_TWC_RESET;
    s->clk_source_sbc1.reg32 = CLK_SOURCE_SBC1_RESET;
    s->clk_source_disp1.reg32 = CLK_SOURCE_DISP1_RESET;
    s->clk_source_disp2.reg32 = CLK_SOURCE_DISP2_RESET;
    s->clk_source_cve.reg32 = CLK_SOURCE_CVE_RESET;
    s->clk_source_ide.reg32 = CLK_SOURCE_IDE_RESET;
    s->clk_source_vi.reg32 = CLK_SOURCE_VI_RESET;
    s->clk_source_sdmmc1.reg32 = CLK_SOURCE_SDMMC1_RESET;
    s->clk_source_sdmmc2.reg32 = CLK_SOURCE_SDMMC2_RESET;
    s->clk_source_g3d.reg32 = CLK_SOURCE_G3D_RESET;
    s->clk_source_g2d.reg32 = CLK_SOURCE_G2D_RESET;
    s->clk_source_ndflash.reg32 = CLK_SOURCE_NDFLASH_RESET;
    s->clk_source_sdmmc4.reg32 = CLK_SOURCE_SDMMC4_RESET;
    s->clk_source_vfir.reg32 = CLK_SOURCE_VFIR_RESET;
    s->clk_source_epp.reg32 = CLK_SOURCE_EPP_RESET;
    s->clk_source_mpe.reg32 = CLK_SOURCE_MPE_RESET;
    s->clk_source_mipi.reg32 = CLK_SOURCE_MIPI_RESET;
    s->clk_source_uart1.reg32 = CLK_SOURCE_UART1_RESET;
    s->clk_source_uart2.reg32 = CLK_SOURCE_UART2_RESET;
    s->clk_source_host1x.reg32 = CLK_SOURCE_HOST1X_RESET;
    s->clk_source_tvo.reg32 = CLK_SOURCE_TVO_RESET;
    s->clk_source_hdmi.reg32 = CLK_SOURCE_HDMI_RESET;
    s->clk_source_tvdac.reg32 = CLK_SOURCE_TVDAC_RESET;
    s->clk_source_i2c2.reg32 = CLK_SOURCE_I2C2_RESET;
    s->clk_source_emc.reg32 = CLK_SOURCE_EMC_RESET;
    s->clk_source_uart3.reg32 = CLK_SOURCE_UART3_RESET;
    s->clk_source_vi_sensor.reg32 = CLK_SOURCE_VI_SENSOR_RESET;
    s->clk_source_spi4.reg32 = CLK_SOURCE_SPI4_RESET;
    s->clk_source_i2c3.reg32 = CLK_SOURCE_I2C3_RESET;
    s->clk_source_sdmmc3.reg32 = CLK_SOURCE_SDMMC3_RESET;
    s->clk_source_uart4.reg32 = CLK_SOURCE_UART4_RESET;
    s->clk_source_uart5.reg32 = CLK_SOURCE_UART5_RESET;
    s->clk_source_vde.reg32 = CLK_SOURCE_VDE_RESET;
    s->clk_source_owr.reg32 = CLK_SOURCE_OWR_RESET;
    s->clk_source_nor.reg32 = CLK_SOURCE_NOR_RESET;
    s->clk_source_csite.reg32 = CLK_SOURCE_CSITE_RESET;
    s->clk_source_osc.reg32 = CLK_SOURCE_OSC_RESET;
    s->utmip_pll_cfg0.reg32 = UTMIP_PLL_CFG0_RESET;
    s->rst_controller_pllc4_base.reg32 = RST_CONTROLLER_PLLC4_BASE_RESET;
    s->rst_controller_pllmb_base.reg32 = RST_CONTROLLER_PLLMB_BASE_RESET;
    s->clk_source_la.reg32 = CLK_SOURCE_LA_RESET;

    /* Enable UARTA */
    s->rst_devices_l.swr_uart1_rst = 0;
    s->clk_out_enb_l.clk_enb_uart1 = 1;

    /* Enable BSEA */
    s->rst_devices_h.swr_bsea_rst = 0;
    s->clk_out_enb_h.clk_enb_bsea = 1;

    /* Enable BSEV */
    s->rst_devices_h.swr_bsev_rst = 0;
    s->clk_out_enb_h.clk_enb_bsev = 1;
    s->rst_devices_h.swr_vde_rst = 0;

    memset(s->regs, 0, sizeof(s->regs));

    if (tegra_board >= TEGRAX1_BOARD) {
        s->rst_cpu_cmplx_clr_offset = RST_CPU_CMPLX_CLR_TEGRAX1_OFFSET;

        for (size_t i=0; i<sizeof(tegra_car_regdef_tegrax1_reset_table)/sizeof(uint32_t); i+=2) {
            uint32_t offset = tegra_car_regdef_tegrax1_reset_table[i];
            uint32_t value = tegra_car_regdef_tegrax1_reset_table[i+1];

            if (offset == RST_DEVICES_L_OFFSET)
                s->rst_devices_l.reg32 = value | 0xC8;
            else if (offset == RST_DEVICES_H_OFFSET)
                s->rst_devices_h.reg32 = value;
            else if (offset == RST_DEVICES_U_OFFSET)
                s->rst_devices_u.reg32 = value;
            else if (offset == CLK_OUT_ENB_L_OFFSET)
                s->clk_out_enb_l.reg32 = value;
            else if (offset == CLK_OUT_ENB_H_OFFSET)
                s->clk_out_enb_h.reg32 = value;
            else if (offset == CLK_OUT_ENB_U_OFFSET)
                s->clk_out_enb_u.reg32 = value;
            else if (offset == PLLU_BASE_OFFSET)
                s->pllu_base.reg32 = value | PLL_LOCKED;
            else if (offset == PLLE_MISC_OFFSET)
                s->plle_misc.reg32 = value;
            else if (offset == RST_CPU_CMPLX_SET_OFFSET || offset == RST_CPUG_CMPLX_SET_OFFSET)
                s->rst_cpu_cmplx_set.reg32 = value;
            else if (offset == s->rst_cpu_cmplx_clr_offset)
                s->rst_cpu_cmplx_clr.reg32 = value;
            else if (offset == CPU_CMPLX_STATUS_OFFSET)
                s->cpu_cmplx_status.reg32 = value;
            else if (offset == RST_CONTROLLER_PLLMB_BASE_OFFSET)
                s->rst_controller_pllmb_base.reg32 = value;
            else if (offset >= RST_DEV_V_SET_OFFSET && offset <= CLK_ENB_W_CLR_OFFSET)
                s->regs[offset>>2] = value;
            else {
                tegra_car_priv_write(s, offset, value, 4);
            }
        }

        s->osc_freq_det_status.osc_freq_det_cnt = 2344;

        // Setup regs as validated by Erista NX_Bootloader with certain versions.
        s->rst_cpu_cmplx_set.reg32 = s->rst_cpu_cmplx_clr.reg32 = 0x2000000F;
    }
    else {
        s->osc_freq_det_status.osc_freq_det_cnt = 1587;

        s->pllc_misc_1.reg32 = PLLC_MISC_1_TEGRA2_RESET;
        s->pllm_misc2.reg32 = PLLM_MISC2_TEGRA2_RESET;
        s->plla_misc.reg32 = PLLA_MISC_TEGRA2_RESET;
        s->pllu_misc.reg32 = PLLU_MISC_TEGRA2_RESET;
        s->pllu_base.reg32 = PLLU_BASE_TEGRA2_RESET | PLL_LOCKED;
        s->rst_cpu_cmplx_clr_offset = RST_CPU_CMPLX_CLR_TEGRA2_OFFSET;
        s->rst_cpu_cmplx_set.reg32 = RST_CPU_CMPLX_SET_TEGRA2_RESET;
    }

    s->rst_controller_pllmb_base.reg32 |= PLL_LOCKED;
}

static const MemoryRegionOps tegra_car_mem_ops = {
    .read = tegra_car_priv_read,
    .write = tegra_car_priv_write,
    .endianness = DEVICE_NATIVE_ENDIAN,
};

static void tegra_car_priv_realize(DeviceState *dev, Error **errp)
{
    tegra_car *s = TEGRA_CAR(dev);

    memory_region_init_io(&s->iomem, OBJECT(dev), &tegra_car_mem_ops, s,
                          "tegra.car", TEGRA_CLK_RESET_SIZE);
    sysbus_init_mmio(SYS_BUS_DEVICE(dev), &s->iomem);
}

static void tegra_car_class_init(ObjectClass *klass, void *data)
{
    DeviceClass *dc = DEVICE_CLASS(klass);

    dc->realize = tegra_car_priv_realize;
    dc->vmsd = &vmstate_tegra_car;
    dc->reset = tegra_car_priv_reset;
}

static const TypeInfo tegra_car_info = {
    .name = TYPE_TEGRA_CAR,
    .parent = TYPE_SYS_BUS_DEVICE,
    .instance_size = sizeof(tegra_car),
    .class_init = tegra_car_class_init,
};

static void tegra_car_register_types(void)
{
    type_register_static(&tegra_car_info);
}

type_init(tegra_car_register_types)
